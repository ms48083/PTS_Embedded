/****************************************************************
   MAINSTREAM_MAIN_V3xx.C

   Purpose:    Main station master control program for Pneumatic Tube Control System
               Works with MAINSTREAM_REMOTE_V3xx.

   Target:     Z-World BL2500 Rabbit

   Language:   Dynamic C 8.x

   Created:    Jun 12, 2006 by Mike Schwedt (C) MS Technology Solutions

   History:
   12-Jun-06   v301 Original version created from UW-PSTS_V228
   13-Sep-06   v302 Change logic state of inputs using bank reads
   21-Sep-06   v303 Fix menu selection for local diverter (make on/off instead of yes/no)
   24-Sep-06   v304 Incorrect order of initialization leading to ram overwriting
   25-Sep-06   v305 Set blwrIDLE = 0 for standard blower configuration
   04-Oct-06   v306 Implement working system reset function in the menu
   22-Oct-06   v307 Further integration of keypad
   23-Oct-06   v308 Fix keypad input in menus, replace F1/F2 with +/-
   26-Oct-06   v309 Reactivate the use of ArrivalEnable to stop false arrival triggers
               	  Show message status of arrival optics
   06-Nov-06	v310 Fix missing LED initialization - now using GLOBAL_INIT
   12-Dec-06   v311 Preparing for integration of dual-main system
                    General code cleanup, refactoring
   08-Jan-07   v312 Bug fixes: slave loop not starting; std trans remains pending
   10-Jan-07   v313 Still tweaking.  Could not set activeMain off.
   					  Separated ALL_DEVICES from availableDevices.
                    Slave device address is now 8.  Remotes can use 1-7.
   11-Jan-07   v314 Slave not registering as a device or stations
   17-Jan-07   v315 Slave messages duplicated as remote messages: Fix -> LAST_STATION = 7 (not 8)
   					  Cleaned up diverter processing at the slave (no diverter, always ready)
   19-Jan-07   v316 Fix to show actual setting of activeMain
   21-Jan-07   v317 Delay communications to eliminate lost packets
   24-Jan-07   v318 Still optimizing communications
   25-Jan-07   v319 Enable TX control a bit sooner to improve communications
                    HD & slave both known at station 8, so ready/not-ready commands now return devAddr
   27-Jan-07	v320 Various improvements while @ Colombo
   28-Jan-07   v321 Prevent loss of communication to toggle remote inputs
   03-Feb-07   v322 Bug fix with last change
   04-Feb-07   v323 Begin color touchscreen integration
   09-Feb-07   v324 Ongoing touchscreen development
   10-Feb-07   v325 Fix for main to main transfers and other improvements @ Colombo
   11-Feb-07   v326 Add main to send station names to slave
   					  Consistently show RCV @ activemain message
                    Handle CIC in slave loop
                    Show if slave has a blocked inline optic
                    Blocked optic at head diverter shows as being at head diverter
                    Process arrival alert and apu blower (if installed) even while in setup menu
   12-Feb-07	v327 Hold off transaction timeout while door is open
                    Ongoing development of menu using color touch screen
   19-Feb-07   v328 Ongoing development of menu using color touch screen
   20-Feb-07   v329 Hit the watchdog during touchscreen initialization
   25-Feb-07   v330 Release menu items for define stations, edit station names, set clock
   26-Feb-07   v331 Minor adjustments, Help->About, cleanup bitmaps, CIC lcd lamp
   01-Mar-07   v332 Complete removal of calls to RN1600 keypad/lcd
   04-Mar-07   v333 Cleanup of existing functions, add transaction summary to logs
   					  Auto Purge to slave added, update message on set active main
   05-Mar-07   v334 Allocate extended xmem for transaction logging
   					  Basic transaction display
   06-Mar-07   v335 Fix for slave entering setup menu in proper mode (std or alarm)
   11-Mar-07   v336 Fix Auto-purge message for purging to slave
   					  Fix Auto-purge exit to make sure blowers shut off right away
                    Show CIC on screen at slave
                    Slave shows help if state is idle
                    Removed <Cancel> button from main menu.  Save is automatic if changes occured.
   12-Mar-07   v337 Misc cleanup while at Colombo
   13-Mar-07   v338 Change font of summary log
   					  Reverse order of transaction log
						  Save statistics to xmem to retain after power reset
                    Allow resetting of statistics from their viewing screen
   14-Mar-07   v339 Center RCV @ message
   				 	  Create <Directory> function
                    Add pin / password capability
                    Add lcd backlight saver
   19-Mar-07	v340 Show slave phone number in directory
   					  Improve slave handling of button presses
                    Put auto-return timer in menu - function not yet implemented
                    Start development of smartPrompt - held off for now due to faulty behavior
                    Auto-exit menu after performing alarm reset
                    Adjust position of waiting for reset message
                    Remove remaining calls to old lcd_print function
                    Increase communication message receive timeout from 50 to 70 msec
                    Don't flash menu update when exiting due to menu timeout
                    Show time units (sec or min) for numeric parameters
	25-Mar-07   v341 Fix slave processing of touchscreen buttons
   					  Move main arrival beep from operator to admin menu
                    On a door open alarm the alarm sound will be on 2 sec and off 5
   27-Mar-07   v342 Invert state of carrier in chamber and arrival optics
   31-Mar-07   v343 Revert to original state of cic and arrival
                    Show main station on slave directory
                    Made Directory a large button
                    Implemented STAT and carrier-return buttons on the main screen
                    Flushed the lcd button presses when entering setup mode because slave sometimes cancels out right away
   04-Apr-07   v344 Implement editing of phone numbers
   					  Reset "RCV @ xxx" message after editing station names
                    Make sure transaction progress bar clears at the end of a transaction
                    On slave startup, if no main communication, send a reset command
                    Mask out unused stations from slave push-to-send
                    Initialize the menu timeout when entering the show directory function
   07-Apr-07   v345 Continue improvements to editing phone numbers
   					  Showing CIC status on station directory
                    Slave Carrier-return implemented
   10-Apr-07   v346 Change C.Return button to Return
   					  Don't blank out progress bar after screen is drawn at Final-Command
                    Fix handling of lcd directory buttons to send main-to-main
                    Phone numbers are sent to the slave unit
   15-Apr-07   v347 Pass CIC data to slave so it can show CIC on the station directory
   					  Pass slave stat button info to main in order to toggle stat on and off
   16-Apr-07   v348 Fixed bug with initialization of default station names - affected new controllers only
   30-Apr-07   v349 Leave backlight at dim level
   					  Move CIC bitmap and rearrange main screen buttons
                    Show STAT button in amber/yellow
                    Fix bug when transaction progress blanks out in CIC area between blower-on and CIC exit
                    Fix bug in edit phone numbers where maintenance incompletely overwrites administrator
                    Implement download of transaction log
                    Put auto-return button on the screen, even if not implemented
   14-May-07   v350 Implement download of communication statistics
   				     Remove slave main buttons during a transaction
                    Allow purging to slave station from the slave manual purge
                    Show introductory help information using Help button
                    Additional level of confirmation for auto-purge
                    Remove slave buttons during a transaction
   21-May-07   v351 Update transaction log to provide future growth
   					  Show all events and transaction status on screen and in download


*****************************************************************/
#define FIRMWARE_VERSION "Mainstream V3.50"
#define STDIO_DISABLE_FLOATS
// define PRINT_ON for additional debug printing via printf
#define PRINT_ON 1
// #define USE_TCPIP 1
#memmap xmem  // Required to reduce root memory usage
#class auto
#use "bl25xx.lib"          Controller library
#use "rn_cfg_bl25.lib"     Configuration library
#use "rnet.lib"            RabbitNet library
#use "rnet_driver.lib"     RabbitNet library
//#use "rnet_keyif.lib"      RN1600 keypad library
//#use "rnet_lcdif.lib"      RN1600 LCD library
// #use "RS232.lib"
#define	LCD_USE_PORTE				// tell Reach library which serial port to use
#use Reach.lib

// Setup interrupt handling for carrier arrival input
// Set equal to 1 to use fast interrupt in I&D space
#define FAST_INTERRUPT 0
char latchCarrierArrival;
void my_isr1();
void arrivalEnable(char how);

// Define communications using TCP/IP (UDP)
#ifdef USE_TCPIP
	#define TCPCONFIG 1
	#define MAX_UDP_SOCKET_BUFFERS 1
	#define LOCAL_PORT   1234
	#define REMOTE_IP    "255.255.255.255" /*broadcast*/
	#define REMOTE_PORT  1234
	#use "dcrtcp.lib"
	udp_Socket sock;
	int sendEthernetCommand(char sample);
#endif

/* Declare data structures */
#define NUMDATA   5
struct iomessage                // communications message packet
{
   char devAddr;                // device board #
   char command;                // command instruction
   char station;                // carrier station #
   char data[NUMDATA];          // process data
};
struct stats_type               // transaction summary statistics
{
   long trans_in;               // incoming transactions
   long trans_out;              // outgoing transactions
   int  deliv_alarm;            // incomplete delivery timeout alarm
   int  divert_alarm;           // diverter timeout alarm
   int  cic_lift_alarm;         // carrier lift timeout alarm
};
struct trans_log_type           // transaction logging info
{
   unsigned long start_tm;      // time of departure
   unsigned long end_tm;        // time of arrival (or alarm)
   char  source_sta;            // where it came from
   char  dest_sta;              // where it went to
   char  status;                // transaction status (0-63) or other event (64-255)
   									  // 0 = no malfunction or other transaction status
                                // 1 = diverter timeout
                                // 2 = carrier exit (lift) timeout
                                // 3 = delivery overdue timeout
                                // 4 = blower timeout
                                // 5 = station not ready after setting diverter or cancel dispatch
                                // 6 = transaction cancelled/aborted (future)
                                // 64 = Door opened event
   char  flags;                 // transaction flags
                                // xxxx xxx1 = Stat Transaction
                                // xxxx xx1x = Carrier return function
                                // xxxx x1xx = Auto return function
                                // xxxx 1xxx = Door opened in transaction
                                // other event flags defined elsewhere
};
// define transaction and event logging status and flags
#define STS_DIVERTER_TOUT  1
#define STS_DEPART_TOUT    2
#define STS_ARRIVE_TOUT    3
#define STS_BLOWER_TOUT    4
#define STS_TRANS_CANCEL   5
#define LAST_TRANS_EVENT  63
#define FLAG_STAT        0x01
#define FLAG_CRETURN     0x02
#define FLAG_ARETURN     0x04
#define FLAG_DOOROPEN    0x08
// define event logging status and flags
#define ESTS_DOOROPEN      64
#define EFLAG_MAINDOOR   0x01
#define EFLAG_SUBSDOOR   0x02
#define EFLAG_EXTRA_CIC  0x04
#define ESTS_MANPURGE      65
#define ESTS_AUTOPURGE     66

// Including parameter block structure
// All parameters here are read to / written from FLASH
struct par_block_type
{  // Define all parameters that are saved in flash
   // They are r/w by readParameterSettings() and writeParameterSettings()
   char sysid;
   char names_init;
	char stacking_ok[2];
   char remote_arrive_alert;
	char localDiverter;      // local diverter configuration
   char activeStations;     // active station set
   int  autoPurgeTimer;     // auto purge timer in seconds
   int  deliveryTimeout;    // delivery timeout in seconds
   char headDiverter;
   char pw_enabled;
   char admPassword[5];    // password for administration functions
   struct {char name[12];} station_name[10];  // 0=main; 1-7=remote; 8=slave; 9=system;
   char slaveController;    // master (0) or slave (>0); who am I
   char activeMain;         // master (0) or slave (>0); who is active
   char adminPassword[5]; // password for administrative functions
   char maintPassword[5]; // password for maintenance functions
   char cfgPassword[5];   // password for system config (Colombo only)
   char phoneNum[11][9];  // phone numbers for stations, admin, maintenance
   char autoReturnTimer;  // how long to wait on unremoved carrier until auto-return
   char main_arrive_alert;
} param;
#define SYSTEM_NAME  9  // last one is the system name   char station_names[12][8];
#define ADMIN_PHONE  9
#define MAINT_PHONE  10

// ------------------------------
// MISCELLANEOUS DEFINITIONS HERE
// ------------------------------
char  alarm_sound_flag;
char diverter_map[9];    // to assign diverter positions to stations
unsigned long diverter_start_time;  // these used primarily by diverter functions
unsigned long menu_timeout;
char diverter_setting;
char diverter_attention;
char printlog_active;    // whether printout of trans log is enabled
char  printer_error;     // stops printing on printer_wait timeout
#define HEADDIVERTERSTATION 0x80 // 8=headdiverter station bit
// ------------------------------
// ------------------------------

//////
// RabbitNet Setup
//int DevRN1600;                   // Rabbit Net Device Number Keypad/LCD
int DevRN1100;                   // Rabbit Net Device Number Digital I/O
#define OUTCONFIG 0xFFFF         //configure outputs to sinking safe state

/////
//local macros
/////
#define ON           0xFF
#define OFF          0x00
#define FLASH        0x01
#define READY        0x01
#define NOT_READY    0xFF
// macros for I/O processing functions
#define INIT       0
#define RUN        1
#define OPERATE    2
#define TRIGGERED  3
#define RUNNING    4
#define HOLD       5
#define ALL_STATIONS 0xFF   // hardware will support 8 stations
#define LAST_STATION    7   // # of bits from STATION_SET  (DON'T COUNT SLAVE FOR NOW)!!!
char    STATION_SET;        // active stations
//char    activeStations;     // as programmed from the menu
char    FIRST_DEVADDR;
char    LAST_DEVADDR;
char    availableDevices;
#define ALL_DEVICES   0xFF
#define MAX_DEVADDRS  8   // maximum number of remote devices
#define MASTER  0x00      // Station number of the master
#define SLAVE   0x08      // Station number of the slave
#define SLAVE_b 0x80      // Bit representation
#define SLAVE_DEVADDR 8
//////////////////////////
// Master/slave variables & function calls
char slaveAvailable;   //
char slaveData[NUMDATA];// special storage for slave status data
char slave_cic, slave_door, slave_rts, slave_rtncarrier; //
char main2mainTrans;   // 0=std.trans; DIR_SEND=mast->slave; DIR_RETURN=slave->mast
char slaveReturnStatus;
char mainStation;
char destMain;
char main2main_trans;
unsigned long lastComTime;
char rts_latch;      /* Used for latching requestToSend */
char activeMainHere; // ONLY FOR USE IN SETUP MENU
void setActiveMainMsg(void);
void setActiveMain(char setToMaster);
void syncDateAndTime(void);	// for master to send clock to slave
void syncTransCount(void);		// for master to send transaction count to slave
void displayRemoteMsgs(char * message_num);  // for master to send lcd msgs to slave
void deliverComControl(char *system_state);  // for master to hand over com to slave
void slaveProcessCommand(struct iomessage message);
void slaveProcessIO(void);
void slaveProcessState(void);
void slaveSyncTransCount(char *p);  // for slave to receive transaction count
void slaveEnableCommands(void);
char slaveGetCommand(struct iomessage *message);
void slaveSendResponse(struct iomessage message);
char slaveComActive(void);  // for slave to know if communication is active
void slaveFinishTransaction(void);
void initTransLog(void);
void downloadTransLog();
void addTransaction(struct trans_log_type trans);
int getTransaction(int entry, struct trans_log_type *trans);
long sizeOfTransLog(void);

/* Serial communications send and receive commands */
#define NAK 0x15
#define ACK 0x06
#define STX 0x02
#define ETX 0x03
#define DINBUFSIZE 63
#define DOUTBUFSIZE 63
#define FINBUFSIZE 63
#define FOUTBUFSIZE 127

/* Remote communication commands */
#define SET_DIVERTER       'A'
#define DIVERTER_STATUS    'B'
#define DIVERTER_READY     'C'
#define DIVERTER_NOT_READY 'D'
#define RETURN_INPUTS      'E'
#define INPUTS_ARE         'E'  // set equal to RETURN_INPUTS (v2)
#define SET_OUTPUTS        'G'
#define CLEAR_OUTPUTS      'H'
#define SET_MODE           'I'
#define ARE_YOU_READY      'J'
#define RETURN_EXTENDED    'K'
#define SET_TRANS_COUNT    'L'
#define SET_DATE_TIME      'M'
#define SET_STATION_NAME   'N'
#define CANCEL_PENDING     'O'
#define TAKE_COMMAND       'P'
#define DISPLAY_MESSAGE    'Q'
#define SET_PHONE_NUMS     'R'
#define TRANS_COMPLETE     'X'
#define RESET              'Y'
#define MALFUNCTION        'Z'

// Declare constant system timeouts
#define DIVERTER_TIMEOUT   30000       // How long to set diverter in msec
#define CIC_EXIT_TIMEOUT   15000       // How long for carrier to escape
#define MALFUNC_TIMEOUT    30000       // How long in malfunction loop
#define PRIORITY_TIMEOUT   120         // Priority reset in seconds
#define PASSWORD_TIMEOUT   10000       // Timeout for operator entry

/* Declare I/O device indexes */
#define devInUseSolid  0
#define devInUseFlash  1
#define devAlert       2
#define devAlarm       3
char outputvalue[4];  // digital output buffers

/* Array index values for remote data returned by INPUTS_ARE command. */
#define REMOTE_CIC      0
#define REMOTE_DOOR     1
#define REMOTE_ARRIVE   2
#define REMOTE_RTS      3

// Digital I/O definitions
// INPUTS
int readDigInput(char channel);
// dio_ON|OFF must be used ONLY in primatives readDigInput and setDigOutput
// they reflect the real state of the logic inputs and outputs
#define dio_ON  0
#define dio_OFF 1
// Menu/Next button assigned to input I-0
#define di_carrierArrival    readDigInput(0)
#define di_carrierInChamber  readDigInput(1)
#define di_doorClosed        readDigInput(2)
#define di_priorityRequest   readDigInput(3)
#define di_returnCarrier     readDigInput(4)
//#define di_requestToSend     ((~digBankIn(1)) & STATION_SET)
#define di_requestToSend     ((~digBankIn(1)) & 0xFF)
#define di_diverterPos       (readDigInput(16) & (readDigInput(17) << 1))
#define di_pushButton(value) !readDigInput(5+value)
char carrierArrival(char whichMain);  // 0=MASTER; 8=SLAVE
char carrierInChamber(char whichMain);
char doorClosed(char whichMain);

// OUTPUTS
void setDigOutput(int channel, int value);
#define do_shift 0
#define do_closeDoorAlarm(value)   setDigOutput(6+do_shift,value)
#define do_blowerVAC(value)        setDigOutput(12+do_shift,value)
#define do_blowerPRS(value)        setDigOutput(13+do_shift,value)
#define do_alert(value)            setDigOutput(11+do_shift,value & param.main_arrive_alert)
#define do_diverter(value)         setDigOutput(8+do_shift,value)
#define do_alarmLight(value)       setDigOutput(9+do_shift,value)
#define do_alarmSound(value)       setDigOutput(10+do_shift,value)
#define do_priorityLight(value)    setDigOutput(14+do_shift,value)
#define do_CICLight(value)         setDigOutput(15+do_shift,value)
#define beep(value)                rn_keyBuzzerAct(DevRN1600, value, 0)
void inUse(char how, char station_b);
void alarm(char how);
//void alert(char how, char station_b);

char getKey(void);
// Functions for digital input based keys
//char  functionButton(char which, char how);
#define  FUNC_BUTT  0x00
#define  FUNC_F1    0x01
#define  FUNC_F2    0x02
#define  FUNC_TRIG  0x01                // triggered (latched) mode
#define  FUNC_CURR  0x02                // current button state
#define  FUNC_HELD  0x03                // auto repeat key
#define  FUNC_DELAY 1000                // auto repeat delay
#define  FUNC_RATE  100                 // auto repeat rate


// LCD definitions
#define DISPROWS 4    //number of lines in display
#define DISPCOLS 16    //number of columns in display
void initializeMessages(void);
void message_add(char lcd, char msg1, char msg2, char how);
void message_del(char lcd, char msg1, char msg2);
void message_show(char how);
void message_refresh(void);
void refresh_timer_message(char msg);
void lcd_initialize(void);
void lputs(char line, char* msg);
void reset_msg_timer(char how);
void lcd_print(char lcd, char line, char* message);
void lcd_show_cursor(char lcd, char line, char pos);
void setTimeMessages(char message, unsigned long timedate);
void setFlagMessage(char flag);
void setParValueMessage(char MSG_message, unsigned long par_value, char * par_units);
void maintenance(void);
#define EMPTY        255      // empty message
#define QUEUESIZE    20       // max number of messages per lcd
#define SCROLLTIME   2000     // 2 seconds
#define NOW          1        // show message immediately
#define NEXT         2        // show message next
#define ONESHOT      3        // show message once right now
#define ONESHOTA     4        // show message once first of 2 oneshots
#define LCDCOUNT     2        // how many lcds connected
#define TRANSLCD     0        // Trasaction Status display
#define SYSTEMLCD    1        // System Status display
/* Define STATIC LCD messages */
#define MSGCOUNT  106
const char * const sysmsg[MSGCOUNT] = {
"  SYSTEM READY  ","  ------------  ",
"<< NEXT TRANS >>","<<  PRIORITY  >>",
" LOG TO PRINTER "," LOCAL DIVERTER ",
" ENTER PASSWORD ","VERIFY PASSWORD ",
" TRANS TIMEOUT  "," PLEASE WAIT... ",
"  SYSTEM ALARM  ","SEE MAINTENANCE ",
"SETTING DIVERTER","   DOOR OPEN    ",
"CARR. IN CHAMBER","DELIV. UNREMOVED",
"DELIVERY OVERDUE"," CARRIER RETURN ",
"  MANUAL PURGE  ","TRANS. CANCELED ",
"NO COMMUNICATION"," FROM REMOTE #  ",
"  WAITING FOR   ","SYSTEM CONFIG   ","SET TIME & DATE ",
"PENDING DELIVERY","    IN ROUTE    ","AT HEAD DIVERTER",
"    TIMEOUT     ","     ERROR      "," REMOTE STATION "," FUNCTION MODE  ",
"   SET HOURS    ","  SET MINUTES   ","  SET SECONDS   ",
"    SET DAY     ","   SET MONTH    ","    SET YEAR    ",
"(+)=UP (-)=DOWN ","(+)=ON  (-)=OFF ","AUTO PURGE TIMER",
"BEEP ON ARRIVAL "," SILENCE ALARM  ","  RESET ALARM   ",
"  SYSTEM RESET  "," SYSTEM IS BUSY ",
"ADMIN FEATURES  ","MAINT FEATURES  ",
"SHOW COMM STATS ","(+)=YES  (-)=NO ",
"   EDIT NAMES   ","IN.OPTIC BLOCKED",
"       @M       ",
"       @1       ","       @2       ","       @3       ","       @4       ",
"       @5       ","       @6       ","       @7       ","       @8       ",
"       <M       ",
"       <1       ","       <2       ","       <3       ","       <4       ",
"       <5       ","       <6       ","       <7       ","       <8       ",
"       >M       ",
"       >1       ","       >2       ","       >3       ","       >4       ",
"       >5       ","       >6       ","       >7       ","       >8       ",
" (+)=PRESSURE   "," (-)=VACUUM     ",
"AUTOMATIC PURGE ","DEFINE STATIONS "," SELECT STATION ",
"--END OF MENU---","   NOT READY    ","  ERROR SAVING  ",
" STACK AT MAIN  ","STACK AT REMOTE "," RESET COUNTER  ",
" TIME: HR:MN    "," DATE: MO/DY/YR ","                ",
" CURRENTLY Oxx  "," MO/DY/YR HR:MN ","   DO NOT USE   ",
"  SET PASSWORD  ","(+)SET  (-)CLEAR",
" HEAD DIVERTER  ","(+)MAIN (-)REMOT",
"PARAMETER VALUE ","ADV SETUP ENABLD",
"RM.ALERT ON STAT","  SET AS SLAVE  ","SET ACTIVE MAIN ",
"                "};      // last element always blank

// Define message indexes into rom or ram messages
enum messageIDs {
 MSG_SDEFAULT    = 0,
 MSG_SDEFAULT2,
 MSG_PRIORITY,
 //MSG_PRIORITY2
 MSG_LOG2PRINTER  = 4,
 MSG_LOCALDIVERTER,
 MSG_ENTERPW,
 // no 7
 MSG_SET_TIMEOUT  = 8,
 MSG_WAIT,
 MSG_ALARM,
 // no 11
 MSG_SETTING     = 12,
 MSG_DROPEN,
 MSG_CIC,
 MSG_ARVALRT,
 MSG_ODUE,
 MSG_RTRN,
 MSG_PURGE,
 // no 19
 MSG_NOCOMM      = 20,
 // no 21,22
 MSG_SYS_CONFIG  = 23,
 MSG_SET_CLOCK,
 MSG_PENDING,
 MSG_INROUTE,
 MSG_AT_HEADDIV,
 MSG_TIMEOUT,
 MSG_ERROR,
 MSG_REMOTESTA,
 MSG_FUNCTION,
 MSG_SET_HOURS,
 // no 33-37
 MSG_INC_DEC     = 38,
 MSG_ON_OFF,
 MSG_APURGE_TIMER,
 MSG_ARRIVE_SND,
 MSG_ALARM_SND,
 MSG_ALARM_RESET,
 MSG_RESET,
 MSG_SYSBUSY,
 MSG_ADMIN_FEAT,
 MSG_MAINT_FEAT,
 MSG_SHOW_COMM,
 MSG_YES_NO,
 MSG_SET_STANAMES,
 MSG_OPTIC_BLOCKED,
 MSG_AT,                 // points to message before station 1
 // no 53-60
 MSG_FROM        = 61,   //   ..
 // no 62-69
 MSG_TO          = 70,   //   ..
 // no 71-78
 MSG_F1_PRESSURE = 79,
 MSG_F2_VACUUM,
 MSG_AUTO_PURGE,
 MSG_DEF_STATIONS,
 MSG_SEL_STATION,
 MSG_END_OF_MENU,
 MSG_NOT_READY,
 MSG_SAVE_ERROR,
 MSG_MSTACKING,
 MSG_RSTACKING,
 MSG_RESET_COUNT,
 MSG_TIME,
 MSG_DATE,
 MSG_TRANS_COUNT,
 MSG_FLAG_SET,     // on/off flag setting
 MSG_DATE_TIME,
 MSG_DONTUSE,
 MSG_SETPASSWORD,
 MSG_SETCLEAR,
 MSG_HEADDIVERTER,
 MSG_MAINREMOTE,
 MSG_PAR_VALUE,
 MSG_ADV_SETUP,
 MSG_RMTALRTSTAT,
 MSG_SETASSLAVE,
 MSG_SETACTIVEMAIN,
 MSG_BLANK			// always the last message
};
#define MSG_TDEFAULT    MSG_DATE_TIME
#define MSG_TDEFAULT2   MSG_TRANS_COUNT

// Define structure and array for variable type messages
// message length is 16 or 20 (+1 for null terminator \n)
#define MSG_LEN 16
struct msgbuftype {char msg[MSG_LEN+1];} sys_message[MSGCOUNT];

// Diagnostic Menu/Setup/Parameters function definitions
void displayFunctionMessage(char mnu_base, char msg_item, char msg_value);
char functionSetTime(char what_timer, char index, unsigned long *time_val);
char functionSetParValue(char menu_item, unsigned long * par_value,
         unsigned long par_min, unsigned long par_max, char * par_units);
char functionDefineStations(void);
int readParameterSettings(void);
int writeParameterSettings(void);

// General/Misc definitions
char init_communication(void);
void showactivity(void);
void msDelay(unsigned int delay);
char secTimeout(unsigned long ttime);
void toggleLED(char LEDDev);
void initialize_system(void);
char bit2station(char station_b);
char station2bit(char station);
char firstBit(char bitdata);
//void diverter(char how);
void set_diverter(char station);
void check_diverter(void);
char divertersReady(char station, char headDiverter, char mainDiverter);
void setDiverterConfiguration(void);
char  valid_send_request(char station_b);
// transaction request queue functions   USE BIT VALUES
void queueAdd(char source, char dest);   // adds request to queue
void queueDel(char source, char dest);   // deletes request from queue
void queueNext(char *source, char *dest);  // returns next queue entry
char queueVerify(char cic_data, char door_data);  // validate queue entries
char send_n_get(struct iomessage message, struct iomessage *response);
char send_command(struct iomessage);
char get_response(struct iomessage *);
char verifyPassword(void);
char setPassword(void);
void clearPassword(void);
char getPassword(char *pwbuff);
void incrementCounter(void);
void reset_statistics(void);
void buildStationNames(void);
//void  initializeMessages(void);
unsigned long transactionCount(void);
void loadTransactionCount(void);
void resetTransactionCount(unsigned long value);
void resetStatistics(void);
void show_extended_data(void);
char extendedData[8][4]; // Extended remote data
void purgeSystem(char auto_purge);
void exercise_outputs(void);
void show_comm_status(void);
void show_comm_test(char wait);
void checkRemoteConfiguration(void);
// PRINTER FUNCTIONS
void print_line(char *buf);
void printer_wait(void);
void print_transaction(struct trans_log_type log);
void print_summary(struct stats_type stats, char how);
void print_malfunction(struct trans_log_type log);
void print_event(char *event);
long nextAutoPrint;
//void reset_printer(void);
void check_auto_report(struct stats_type stats);
void reset_auto_print(void);
void time2string(unsigned long time, char *buf, int format);
void lcd_splashScreen(char view);
void lcd_helpScreen(char view);
void lcd_drawScreen(char whichScreen, char *title);
void lcd_displayMsgs(char * message_num);  // to show msgs on touch screen
void lcd_printMessage(char line, char * msg);
void lcd_processTouchScreen(int button);
void lcd_enterSetupMode(char operatorLevel);
void lcd_ShowTransactionProgress(char source, char dest, char direction, int progress, unsigned long transTimer);
char lcd_SelectChoice(char *choice, char *label, char *optZero, char *optOne);
char lcd_GetNumberEntry(char *description, unsigned long * par_value,
         unsigned long par_min, unsigned long par_max, char * par_units, char max_digits);
char lcd_enableAdvancedFeatures(char menu_level, char * description);
char lcd_getPin(char *PIN, char *description);
int  lcd_Center(char * string, char font);
void lcd_clearMiddle(void);
void lcd_ShowKeypad(char opts);
void lcd_drawKeyboard(void);
char lcd_editStationNames(void);
char lcd_editPhoneNums(void);
void lcd_showCIC(char forceit);
void lcd_setClock(void);
char lcd_defineActiveStations(void);
void lcd_showTransSummary(void);
void lcd_showDirectory(char mode);
void lcd_showPage(int thisPage, int lastPage);
void lcd_showTransPage(int page, int lastPage);
void lcd_showTransactions(void);
char lcd_sendTo(void);
char lcd_returnCarrier(void);
void lcd_screenSaver(char brightness);
void lcd_smartPrompt(char promptNum);
char * ltrim(char * text);
char echoLcdToTouchscreen;  // to control echo of lcd messages to the touch screen
#define  lcd_NO_BUTTONS        ""
#define  lcd_WITH_BUTTONS      " "
#define  LCD_DIM               0
#define  LCD_BRIGHT            4
#define	BMP_COLOMBO_LOGO		 1
#define	BMP_green_light		 2
#define	BMP_red_light			 3
#define 	BMP_check_box			 4
#define	BMP_check_box_click	 5
#define	BMP_button_on         6
#define	BMP_button_off        7
#define	BMP_button_up         8
#define	BMP_button_dn         9
#define	BMP_input_box			 10
#define	BMP_med_button        11
#define	BMP_med_button_dn     12
#define	BMP_long_button       13
#define	BMP_long_button_dn    14
#define	BMP_92x32_button      15
#define	BMP_92x32_button_dn   16
#define	BMP_med_red_button    17
#define	BMP_med_red_button_dn 18
#define	BMP_med_grn_button    19
#define	BMP_med_grn_button_dn 20
#define	BMP_92x40_button      21
#define	BMP_92x40_button_dn   22
#define	BMP_med_yel_button    23
#define	BMP_med_yel_button_dn 24
#define	BMP_ltgrey_light		 25

#define  BTN_MENU              1
#define  BTN_DIRECTORY         2
//#define  BTN_HELP              3
#define  BTN_STAT              4
#define  BTN_CRETURN           5
#define  BTN_ARETURN           6
#define  BTN_OK                10
#define  BTN_CANCEL            11
#define  BTN_SAVE              12
#define  BTN_PREV              13
#define  BTN_NEXT              14
#define  BTN_HELP              15
#define  BTN_YES_ON            16
#define  BTN_NO_OFF            17
#define  BTN_DEL               18
#define  BTN_EXIT              19
#define  BTN_MNU_FIRST         21


// State Processing definitions
void processSystemIO(void);
char processKeyInput(void);
void processCycleTime(void);
void processMainArrivalAlert(void);
void processStatPriority(void);
//void processOutputLamps(char olOperation);
char checkDoorWhileRunning(char calling_state);

/* Declare system states */
#define  IDLE_STATE             0x01
#define  PREPARE_SEND           0x02
#define  WAIT_FOR_DIVERTERS     0x03
#define  BEGIN_SEND             0x04
#define  WAIT_FOR_MAIN_DEPART   0x05
#define  WAIT_FOR_REM_ARRIVE    0x06
#define  HOLD_TRANSACTION       0x07
#define  WAIT_FOR_REM_DEPART    0x08
#define  WAIT_FOR_MAIN_ARRIVE   0x09
#define  WAIT_FOR_HEADDIVERTER  0x0A
#define  SHIFT_HEADDIVERTER     0x0B
#define  CANCEL_STATE           0x0C
#define  MALFUNCTION_STATE      0x0D
#define  FINAL_COMMAND          0x0E

#define  DIR_SEND             1
#define  DIR_RETURN           2

// Declare blower interfaces
#define blwrOFF  0
// in standard blower systems blwrIDLE and blwrOFF are both 0 = OFF.
// in APU blower systems blwrIDLE is 1
#define blwrIDLE 0
#define blwrVAC  2
#define blwrPRS  3

char blwrConfig; // later to become parameter from eeprom

void blower(char blowerOperatingValue);  // use blwrOFF, blwrIDLE, blwrVAC, blwrPRS
char processBlower(void);
char blowerPosition(void);

// Blower state is based on system_state -> [system_state][blwrConfig]
// blwrConfig APPEARS to be standard system (0) or head-diverter (1)
// Independent of blower type standard or APU
const char blowerStateTable[15][2] = {
	blwrOFF,  blwrOFF,	 // Undefined state 0
	blwrIDLE, blwrIDLE,  // 0x01 (Idle)
	blwrIDLE, blwrIDLE,  // 0x02
	blwrIDLE, blwrIDLE,  // 0x03
	blwrIDLE, blwrIDLE,  // 0x04
	blwrPRS,  blwrVAC,   // 0x05 (Main departure)
	blwrPRS,  blwrPRS,   // 0x06 (Remote arrival)
	blwrIDLE, blwrIDLE,  // 0x07
	blwrVAC,  blwrVAC,   // 0x08 (Remote departure)
	blwrVAC,  blwrPRS,   // 0x09 (Main arrival)
	blwrIDLE, blwrVAC,   // 0x0A (Wait for headdiverter)
	blwrIDLE, blwrIDLE,  // 0x0B
	blwrIDLE, blwrIDLE,  // 0x0C
	blwrOFF,  blwrOFF,   // 0x0D
	blwrIDLE, blwrIDLE };// 0x0E


// Globals, system parameters, variables for process state information
char op_mode, saved_state;
unsigned long arrival_time;
unsigned long state_timer;
char diagnostic_mode;
char system_state, systemStation, systemStationb, malfunctionActive;
char priority, system_direction, memory_state, arrival_alert;
char btnStatFlag;
char arrival_from;
unsigned long main_arrival;
unsigned long slave_arrival;
unsigned long priority_seconds;
static struct stats_type statistics;

void main()
{
   /* Declare local variables */
   struct iomessage testcmd, testrsp;
   unsigned long testtime, t1, t2, comfail;
   char i;
   char * genptr;
   auto rn_search newdev;
   int status;

   // Initialize the controller
   brdInit();              // Initialize the controller
   rn_init(RN_PORTS, 1);   // Initialize controller RN ports

   // Verify that the Rabbitnet boards are connected
   newdev.flags = RN_MATCH_PRDID;
   newdev.productid = RN1100;
   if ((DevRN1100 = rn_find(&newdev)) == -1)
   {
      printf("\n no RN1100 found\n");
   }
   else status = rn_digOutConfig(DevRN1100, OUTCONFIG);  //configure safe state

	// allocate xmem for transaction log
	initTransLog();

   // setup diverter mappings.
   setDiverterConfiguration();

   hitwd();          // "hit" the watchdog timer

   /* Initialize digital outputs */
   inUse(OFF, ALL_STATIONS);
   do_alert(OFF);
   alarm(OFF);
 	blower(blwrOFF);

   init_communication();          // Initialize serial communications

#ifdef USE_TCPIP
   sock_init();	   				// Initialize processor UDP communications
   if(!udp_open(&sock, LOCAL_PORT, resolve(REMOTE_IP), REMOTE_PORT, NULL))
   {  printf("udp_open failed!\n");
      //lcd_print(1, 0, "No IP Communications");
      msDelay(1000);
   }
#endif

   /* Initialize LCD displays */
   hitwd();
   //lcd_initialize();
   message_del(0, EMPTY, EMPTY);    // initialize both lcd queues
   lcd_splashScreen(0);
	//lcd_print(TRANSLCD, 0, FIRMWARE_VERSION);
   //lcd_print(TRANSLCD, 1, "PLEASE WAIT...  ");

   hitwd();

   // Initialize other system configuration
   initialize_system();
   initializeMessages();     // Initialize dynamic (RAM) messages
   loadTransactionCount();   // Read transaction counter from EEPROM

   /* Exercise all lighted outputs except on watchdog reset */
   // if (!wderror())
   if (1) // don't have way to check if reset was by watchdog
   {
	   // show missing H/W on LCD
	   if (DevRN1100 == -1)
	   {  //lcd_print(1, 0, "NO RN1100 FOUND...  ");
		   lcd_DispText("NO RN1100 DETECTED\n",0, 0, MODE_NORMAL);
	      //msDelay(1000);
	   }

      // Perform bulb check
	   lcd_DispText("Indicator Check\n",0, 0, MODE_NORMAL);
      exercise_outputs();
      if (param.slaveController == 0)
      {
//while (1)
//{ // endless loop to check com
	      checkRemoteConfiguration();             // how many remotes, etc.
//digBankOut(0, availableDevices);
//toggleLED(1);
//msDelay(1000);
//toggleLED(1);
//digBankOut(0, 0);
//}

	      //lcd_print(SYSTEMLCD, 0, " COMMUNICATION  ");
	      //lcd_print(SYSTEMLCD, 1, "TEST STATISTICS ");

	      // send message for 3 seconds and show statistics
	      testcmd.devAddr=ALL_DEVICES;
	      testcmd.command=RETURN_INPUTS;
	      testcmd.station=0;
	      testcmd.data[0]=0;
	      testcmd.data[1]=0;
	      testcmd.data[2]=0;
	      for (i=0; i<3; i++)
	      {
	         hitwd();
	         testtime=MS_TIMER;
	         while (MS_TIMER-testtime < 1000)
	         { msDelay(7);
	           send_n_get(testcmd, &testrsp);
	         }
	      }
	      show_comm_test(0); // don't wait
	      // One more command for extended data
	      testcmd.command=RETURN_EXTENDED;
	      send_n_get(testcmd, &testrsp);
	      // Show extended data
	      show_extended_data();

         syncDateAndTime();  // put the clock out on the com bus
         if (slaveAvailable) setActiveMain(ON); // default to receive here
	   }
	   else
	   {  // what to do for slave startup
/*	      lcd_print(TRANSLCD, 0,  "  WAITING FOR   ");
	      lcd_print(TRANSLCD, 1,  "  COMMAND FROM  ");
	      lcd_print(SYSTEMLCD, 0, " MASTER CONTROL ");
	      lcd_print(SYSTEMLCD, 1, "  PLEASE WAIT...");
*/	      //availableDevices = 0; // incoming commands will set this up
	      STATION_SET = 0; // incoming commands will set this up
         setActiveMain(OFF);  // default to not receive here
	   }
   }
   else
   {
      //lcd_print(SYSTEMLCD, 0, "  SYSTEM RESET   ");
      //lcd_print(SYSTEMLCD, 1, "WATCHDOG TIMEOUT ");
      //msDelay(3000);
   }

   // setup interrupt handler for arrival optics
#if __SEPARATE_INST_DATA__ && FAST_INTERRUPT
	interrupt_vector ext1_intvec my_isr1;
#else
	SetVectExtern3000(1, my_isr1);
   // re-setup ISR's to show example of retrieving ISR address using GetVectExtern3000
	SetVectExtern3000(1, GetVectExtern3000(1));
#endif
	WrPortI(I1CR, &I1CRShadow, 0x09);		// enable external INT1 on PE1, rising edge, priority 1

	// Setup standard display of color touchscreen
   lcd_drawScreen(1,lcd_WITH_BUTTONS);

	/* BEGIN MAIN LOOP */
   if (param.slaveController==0)
   {
	   while(1)
	   {
	      maintenance();  // watchdog, led activity, UDP commands, inUse lights
	      //rn_keyProcess(DevRN1600, 0);  // process keypad device
	      showactivity();      // flashes the board led
	      show_comm_status();  // update lcd with comm status
	      message_show(NEXT);  // show next message in queue
	      processSystemIO();   // check system processes
         lcd_processTouchScreen(-2);  // get a new button press
	   }
   } else // SLAVE MAIN LOOP
   {	slaveEnableCommands();
		while(1)
      {
	      maintenance();  // watchdog, led activity, UDP commands, inUse lights
	      //rn_keyProcess(DevRN1600, 0);  // process keypad device
	      showactivity();      // flashes the board led
         slaveProcessIO();
      }
   }
}
nodebug root interrupt void my_isr1()
{
	latchCarrierArrival=TRUE;
  	WrPortI(I1CR, &I1CRShadow, 0x00);		// disble external INT1 on PE1
}
void arrivalEnable(char how)
{
   // should call this routine once to enable interrupt and once to disable

   if (how)
   {   //outport(ITC,(inport(ITC))|0x02);      // enable  INT1
   	WrPortI(I1CR, &I1CRShadow, 0x09);		// enable external INT1 on PE1, rising edge, priority 1
   } else
   {   //outport(ITC,(inport(ITC))&~0x02);     // disable INT1
   	WrPortI(I1CR, &I1CRShadow, 0x00);		// disble external INT1 on PE1
   }
   latchCarrierArrival=FALSE;    // clear existing latch
}

void initialize_system()
{  // Setup system i/o processing routine
   char i;

   if ( readParameterSettings() != 0)
   {  //lcd_print(1, 0, "ERROR READING PARAMS");
	   lcd_DispText("ERROR LOADING PARAMETERS",0, 0, MODE_NORMAL);
      //msDelay(800);
   }
   // data type mismatch, force two parameters to char
   param.deliveryTimeout &= 0xFF;
   param.autoPurgeTimer &= 0xFF;

   // setup other globals
   priority=0;
   btnStatFlag=0;
   outputvalue[0]=0;     // clear expansion bus output buffers
   outputvalue[1]=0;
   outputvalue[2]=0;
   outputvalue[3]=0;
   arrival_alert=0;
   main_arrival=0;
   arrival_from=0;
   systemStation=0;
   systemStationb=0;
   param.main_arrive_alert=TRUE;
   alarm_sound_flag=TRUE;
   malfunctionActive=FALSE;
   echoLcdToTouchscreen=TRUE;
	latchCarrierArrival=FALSE;  // clear latch

   reset_statistics();
   queueDel(0,0);            // initialize request queue

   for (i=0; i<NUMDATA; i++) slaveData[i]=0;  // init slave i/o

   // check headdiverter configuration and make sure it is valid
   if ((param.headDiverter != TRUE) && (param.headDiverter != FALSE)) param.headDiverter=FALSE;
   if (param.headDiverter) param.activeStations |= 0x80;  // station 8 programmed by headdiverter setting
   STATION_SET = param.activeStations;

   // make sure passwords are valid (4 digits, trailing null)
   for (i=0; i<4; i++)
   {
   	if ((param.adminPassword[i] < '0') || (param.adminPassword[i] > '9'))
      	param.adminPassword[0]=0; // reset pw
   	if ((param.maintPassword[i] < '0') || (param.maintPassword[i] > '9'))
      	param.maintPassword[0]=0; // reset pw
   	if ((param.cfgPassword[i] < '0') || (param.cfgPassword[i] > '9'))
      	strcpy(param.cfgPassword, "2321"); // reset pw
   }
   // make sure phone numbers are valid
   for (i=0; i<11; i++) { if (strlen(param.phoneNum[i]) > 9) param.phoneNum[i][0]=0; }
// DEBUG UNTIL EDIT PHONE NUMBERS IS IMPLEMENTED
// for (i=0; i<10; i++) { strcpy(param.phoneNum[i], "123-4567"); }
   // setup transaction count message
   setParValueMessage(MSG_TRANS_COUNT, transactionCount(), "");
}

void processCycleTime()
{  // calculate and display cycle time statistics
#define CYCLETIME_UPDATE 2000
   static int ct_min, ct_avg, ct_max;
   static int ct_loops;
   static unsigned long cycle_start;
   static unsigned long ct_last;
   unsigned long cycle_time;

   if (MS_TIMER - cycle_start >= CYCLETIME_UPDATE)
   {  if (ct_loops > 0) ct_avg = (int)((MS_TIMER - cycle_start) / ct_loops);
      printf("\n n=%d min=%d avg=%d max=%d", ct_loops, ct_min, ct_avg, ct_max);
      ct_max=0;
      ct_min=32767;
      ct_loops=0;
      cycle_start=MS_TIMER;
   }
   else
   {
      cycle_time = MS_TIMER - ct_last;
      ct_loops = ct_loops + 1;
      if (cycle_time > ct_max) ct_max = (int)cycle_time;
      if (cycle_time < ct_min) ct_min = (int)cycle_time;
   }
   ct_last = MS_TIMER;
}

char remote_data[4];
// event log is modified in multiple modules so make global
struct trans_log_type eventlog;
void processSystemIO()
{
   struct iomessage command, response, xtended;
	static struct iomessage finalcmd;
   char received, k, kbit, XtraCic, FirstXtraCic;
   static char new_state;
   static char systemStartup;
   char func, menu_item, func_mode;
   static char first_time_here;
   static char lcd_is_bright;
   char tempData;
   //char remote_data[4];
   static struct trans_log_type translog;
//   int safetyStatus;
   static unsigned long auto_purge_timer;
   static unsigned long lastComTimer;
   static int transProgress;
   static unsigned long doorOpenTimer;  // How long door is open during a transaction in seconds
   char key;
   // setup structure for handling transaction types and info lookup
   enum TRANTYPES
   { 	TT_NONE = 0,
      TT_MAIN2REMOTE,
      TT_REMOTE2MAIN,
      TT_SLAVE2REMOTE,
      TT_REMOTE2SLAVE,
      TT_MAIN2SLAVE,
      TT_SLAVE2MAIN
   };
   enum TRANSINFOS
   {  TT_MAINSTATION = 0,
   	TT_MAIN2MAIN_TRANS,
      TT_SYSTEM_DIRECTION,
      TT_FROM,					// For head diverter alignment
      TT_TO                // For head diverter alignment
   };
   enum TRANSLOCS
   {  TT_MAIN = 1,
   	TT_REMOTE,
      TT_SLAVE
   };
	static char transactionType;
   // create lookup table for transaction parameters
   static const char transTypeInfo[7][5] = {  // mainStation, main2main_trans, system_direction, from, to
   0, 0, 0,	0, 0,							// NONE
   MASTER, 0, DIR_SEND, TT_MAIN, TT_REMOTE,				// MAIN TO REMOTE
   MASTER, 0, DIR_RETURN, TT_REMOTE, TT_MAIN,			// REMOTE TO MAIN
   SLAVE,  0, DIR_SEND, TT_SLAVE, TT_REMOTE,				// SLAVE TO REMOTE
   SLAVE,  0, DIR_RETURN, TT_REMOTE, TT_SLAVE,			// REMOTE TO SLAVE
   MASTER, DIR_SEND, DIR_SEND, TT_MAIN, TT_SLAVE,		// MAIN TO SLAVE
   SLAVE,  DIR_RETURN, DIR_SEND, TT_SLAVE, TT_MAIN };	// SLAVE TO MAIN

   #GLOBAL_INIT
   {
	   first_time_here = TRUE;
	   system_state=CANCEL_STATE;
      new_state=system_state;
	   state_timer=MS_TIMER;
      lastComTimer=0;
      transProgress=101;  // handle CIC only;  use 999 to clear the area
      systemStartup=TRUE;  // resets after getting through FINAL_COMMAND
      lcd_is_bright=TRUE;
      remote_data[REMOTE_CIC]=0;  // clear out because slave will use it and it may not be initialized
	}

   // First process items always needing attention
   check_diverter();
   // processBlower(); NOW HANDLED IN maintenance()
   processCycleTime();
   //processMainArrivalAlert(); NOW HANDLED IN maintenance()
   lcd_ShowTransactionProgress(mainStation, systemStation, system_direction, transProgress, SEC_TIMER-translog.start_tm);
   key = getKey(); // processKeyInput();

   // Handle STAT processing
   processStatPriority();


   // if main door open, add message, else del.
   if ( di_doorClosed )
   {  message_del(SYSTEMLCD, MSG_DROPEN, MSG_AT); }
   else
   {  message_add(SYSTEMLCD, MSG_DROPEN, MSG_AT, NEXT); }

   // show carrier in chamber
   if ( di_carrierInChamber )
      message_add(SYSTEMLCD, MSG_CIC, MSG_AT, NEXT);
   else
      message_del(SYSTEMLCD, MSG_CIC, MSG_AT);

   // show if arrival optic is blocked
   if ( di_carrierArrival && (system_state==IDLE_STATE) )
      message_add(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT, NEXT);
   else
      message_del(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT);

// DON'T RUN COMMUNICATIONS ANY MORE THAN THE BUS CAN HANDLE
if (MS_TIMER - lastComTime > 10)
{  lastComTime = MS_TIMER;
   // Check some remote inputs ... sends some data also
   command.devAddr=ALL_DEVICES;
   command.command=RETURN_INPUTS;
   command.station=param.activeMain;
   // send the main arrival state to indicate not ready for transaction
   if (main_arrival || slave_arrival) command.data[0]=arrival_from;
   else command.data[0]=0;
   // send the system_state (for headdiverter controller to operate blower)
   command.data[1]=system_state;
   command.data[2]=outputvalue[devInUseSolid];		// was system_direction;
   command.data[3]=outputvalue[devInUseFlash];
   command.data[4]=STATION_SET;

   if (send_n_get(command, &response))
   {
      if (response.command==INPUTS_ARE)
      {
        // store remote response in local var
        for (k=0; k<4; k++)
        {  tempData = response.data[k];
           tempData &= response.station;  // Turn off unused bits
           remote_data[k] |=  (tempData & response.station);  // ON Bits
           remote_data[k] &= ~(tempData ^ response.station); // OFF bits
        }
        // force unused doors closed (on) and other unused inputs off
        remote_data[REMOTE_DOOR] |= ~STATION_SET;
        remote_data[REMOTE_CIC] &= STATION_SET;
        remote_data[REMOTE_RTS] &= STATION_SET;
        remote_data[REMOTE_ARRIVE] &= STATION_SET;

	      // store slave response in local vars
	      if (slaveAvailable)
	      {  if (slaveData[0] & 0x01)      // slave carrier in chamber
	         {   slave_cic = TRUE;
                message_add(SYSTEMLCD, MSG_CIC, MSG_AT+SLAVE, NEXT);
	         } else
	         {  slave_cic=FALSE;
	            message_del(SYSTEMLCD, MSG_CIC, MSG_AT+SLAVE);
            }
	         if (slaveData[0] & 0x02)      // slave door
	         {   slave_door = TRUE;  // closed
	             remote_data[REMOTE_DOOR] |= SLAVE_b;
                message_del(SYSTEMLCD, MSG_DROPEN, MSG_AT+SLAVE);
	         } else
	         {   slave_door = FALSE;
                message_add(SYSTEMLCD, MSG_DROPEN, MSG_AT+SLAVE, NEXT);
            }
            if (slaveData[0] & 0x04)		// show message if slave optic blocked
				{  message_add(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT+SLAVE, NEXT);
            } else
            {  message_del(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT+SLAVE);
            }
            if (slaveData[0] & 0x10) btnStatFlag=2;  // clear stat from slave
	         slave_rts = slaveData[1];     // slave request to send
	         slaveReturnStatus = slaveData[2];  // slave status

	         // check status change request
	         if (system_state==IDLE_STATE || system_state==MALFUNCTION_STATE)
	         {  if (slaveReturnStatus & 0x02) param.activeMain=SLAVE;
	            if (slaveReturnStatus & 0x04) param.activeMain=MASTER;
               if (slaveReturnStatus & 0x06)   // active main changed
               {  // logActiveChange(8);
                  setActiveMainMsg();
                  activeMainHere = (param.activeMain==MASTER);  // FOR SETUP MENU
               }
	            if (slaveReturnStatus & 0x08) deliverComControl(&system_state);
               if (slaveReturnStatus & 0x20) system_state=CANCEL_STATE;
               if (slaveReturnStatus & 0x40) slave_rtncarrier=TRUE; else slave_rtncarrier=FALSE;
	         }

	         // check for remote to cancel transaction
	         if (slaveReturnStatus & 0x01 && (mainStation==SLAVE))
	            system_state=CANCEL_STATE;    // cancel immediately

	      } else slave_door = TRUE;  // need to close unused door


        // flash inuse when cic and not stacking
        if (remote_data[REMOTE_CIC] && !param.stacking_ok[1])
        {
          // flash those with carriers unless stacking is allowed
          if (malfunctionActive) inUse(FLASH, remote_data[REMOTE_CIC]);
          else inUse(FLASH, remote_data[REMOTE_CIC] & ~systemStationb);
        }
        // turn others off except system station
        if (malfunctionActive) inUse(OFF, ~remote_data[REMOTE_CIC]);
        else inUse(OFF, ~remote_data[REMOTE_CIC] & ~systemStationb);

        // for each with the door open and no cic, clear the arrival-alert
        if (arrival_alert)
           arrival_alert &= (remote_data[REMOTE_CIC]
                         | remote_data[REMOTE_DOOR])
                         & ~systemStationb;

        // clear slave arrival alert as necessary
        if (slave_arrival)
        {  if ( (slave_door==FALSE && slave_cic==FALSE)
               || ((mainStation==SLAVE) && (system_direction==DIR_SEND)) )
           {  slave_arrival=0;
		        message_del(SYSTEMLCD, MSG_ARVALRT, MSG_AT+SLAVE);
              arrival_from=0;
           }
        }

       // for each station, check several conditions.
       for (k=1; k<=LAST_STATION; k++)
       {
          kbit=station2bit(k);      // setup bit equivalent

          // for each with a door open, add door message, else del.
          if (remote_data[REMOTE_DOOR] & kbit)
             	message_del(SYSTEMLCD, MSG_DROPEN, MSG_AT+k);
          else message_add(SYSTEMLCD, MSG_DROPEN, MSG_AT+k, NEXT);

          // for each with a carrier, add carrier message ... else del.
          if (remote_data[REMOTE_CIC] & kbit)
             	message_add(SYSTEMLCD, MSG_CIC, MSG_AT+k, NEXT);
          else message_del(SYSTEMLCD, MSG_CIC, MSG_AT+k);

          // for each with a request-to-send, add pending message, else del.
          if (remote_data[REMOTE_RTS] & kbit)
             	message_add(SYSTEMLCD, MSG_PENDING, MSG_FROM+k, NEXT);
          else message_del(SYSTEMLCD, MSG_PENDING, MSG_FROM+k);

          // for each with arrival-alert, add warning, else del.
          if (arrival_alert & kbit)
             	message_add(SYSTEMLCD, MSG_ARVALRT, MSG_AT+k, NEXT);
          else message_del(SYSTEMLCD, MSG_ARVALRT, MSG_AT+k);

          // for each with blocked arrival optic add message
          if (remote_data[REMOTE_ARRIVE] & kbit)
             	message_add(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT+k, NEXT);
          else message_del(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT+k);

        }
        // check for head diverter blocked optic
        if (param.headDiverter)
        {  if (remote_data[REMOTE_ARRIVE] & 0x80)  // HARD CODE TO BIT 8
	            message_add(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT_HEADDIV, NEXT);
	        else message_del(SYSTEMLCD, MSG_OPTIC_BLOCKED, MSG_AT_HEADDIV);
        }
      }
   }
}

   // Check function button requests
   // func = functionButton(FUNC_BUTT, FUNC_TRIG);
/*   if (key == KEYMENUNEXT)
   {  if ( (system_state == IDLE_STATE) || (system_state == MALFUNCTION_STATE) )
      {  // Enter function mode
         menu_item=0;
         enterSetupMode(menu_item, &system_state);
      } else
      { // display message how to reset system
         message_add(TRANSLCD, MSG_FUNCTION, MSG_SYSBUSY, ONESHOT);
         // FOR NOW DON'T TELL HOW TO DO A RESET --> NEED TO FIGURE OUT RIGHT WAY TO DO IT
         // message_add(SYSTEMLCD, MSG_SYSBUSY+1, MSG_SYSBUSY+2, ONESHOT);
      }
   }
*/
   // if system_reset (Abort) and state is not normal|malfunc, cancel
   // DON'T HAVE A GOOD WAY TO DO THIS AT THE MOMENT
   //while (  functionButton(FUNC_BUTT, FUNC_CURR)
   //   && functionButton(FUNC_F1, FUNC_CURR)
   //   && functionButton(FUNC_F2, FUNC_CURR)
   //   && (system_state != IDLE_STATE)
   //   && (system_state != MALFUNCTION_STATE)) system_state=CANCEL_STATE;


   // LAST REMOTE COMMAND BEFORE PROCESSING MUST BE "RETURN_INPUTS"


   switch (system_state)
   {
      case IDLE_STATE:
         lcd_screenSaver(LCD_DIM);  // handle backlight screen saver
         transactionType = TT_NONE;  // make sure we start with no request
         destMain = MASTER;
	      transProgress=101;  // no activity
         doorOpenTimer=0;
         translog.flags = 0;
			translog.status = 0;

         // update smartPrompt
         // if no carrier then show prompt "insert carrier"
         // if carrier and no arrival-alert show prompt "press directory"
/*         if (main_arrival==0)
         { 	if (carrierInChamber(MASTER)) lcd_smartPrompt(2); // press directory
         	else lcd_smartPrompt(1); // insert carrier
         }
*/
	      // Check carrier return function
	      if (di_returnCarrier || lcd_returnCarrier())
	      {  // determine which carrier to return
            systemStationb = (di_requestToSend | station2bit(lcd_sendTo())) & STATION_SET;
         	if ( di_doorClosed &&
	            ( systemStationb & remote_data[REMOTE_CIC] & remote_data[REMOTE_DOOR]) )
	         {
	            systemStation=bit2station(systemStationb);
               translog.flags = FLAG_CRETURN;
	            if ((systemStation==SLAVE) && (slave_cic))
	            {  transactionType = TT_SLAVE2MAIN;
	            } else if ( (systemStation!=SLAVE) &&
	                  ( systemStationb & remote_data[REMOTE_CIC] & remote_data[REMOTE_DOOR]) )
	            {  transactionType = TT_REMOTE2MAIN;
	            }
	         }
	      }
	      // check slave carrier_return request next
	      else if (slaveAvailable && slave_rtncarrier && slave_door) // carrier return function
	      {  // first check for master to slave
	         systemStation=bit2station(slave_rts);
            translog.flags = FLAG_CRETURN;
	         if ((systemStation==SLAVE) && di_carrierInChamber)
	         {  transactionType = TT_MAIN2SLAVE;
	         } // otherwise check for carrier return from remote
	         else if ( (systemStation!=SLAVE) &&
	               (slave_rts & remote_data[REMOTE_CIC] & remote_data[REMOTE_DOOR]) )
	         {  transactionType = TT_REMOTE2SLAVE;
	         }
	      }
	      // check slave outbound requests next
	      else if (slaveAvailable && !priority && (slave_rts & STATION_SET) && slave_cic)
	      {  // slave station outbound to remote
	         if ( !(remote_data[REMOTE_CIC] & slave_rts & STATION_SET) || param.stacking_ok[1])
	         {  systemStation=firstBit(slave_rts);
	            // check for main to main transaction
	            if (systemStation==SLAVE) { transactionType = TT_SLAVE2MAIN; }
               else							  { transactionType = TT_SLAVE2REMOTE; }
	         } else
	         {  // tell slave to clear rts_latch
	            command.devAddr=ALL_DEVICES;
	            command.command=CANCEL_PENDING;
	            send_command(command);
	         }
	      }

	      // check remote requests next
	      else if (!priority && (remote_data[REMOTE_RTS] & STATION_SET))
	      { // which active main?
	         if (param.activeMain==SLAVE && slaveAvailable)
	         {  // send to slave
	            if ( ((slave_cic==FALSE && slave_arrival==0) || param.stacking_ok[0]) && (slave_door==TRUE) )
	            {  transactionType = TT_REMOTE2SLAVE;
	               systemStation=firstBit(remote_data[REMOTE_RTS]);
 	            }
	         } else    // active_main == MASTER
	         {  // only if (no carrier and no arrival_alert) or (stacking is ok)
	            if ( (di_carrierInChamber==FALSE && main_arrival==0) || param.stacking_ok[0])
	            {  // OK if main door is closed otherwise signal alert
	               if (di_doorClosed)
	               {  transactionType = TT_REMOTE2MAIN;
	                  systemStation=firstBit(remote_data[REMOTE_RTS]);
	               } else {  do_alert(ON); }
	            }
            }
         } else
         {  // check main request
            systemStationb = (di_requestToSend | station2bit(lcd_sendTo())) & STATION_SET;
            // proceed if good send request, no carrier or stacking
            if ((valid_send_request(systemStationb)==0)
               && ( !(remote_data[REMOTE_CIC] & systemStationb) || param.stacking_ok[1]))
            {  systemStation=bit2station(systemStationb);
	            // check for main to main transaction
	            if (systemStation==SLAVE) { transactionType = TT_MAIN2SLAVE; }
	            else							  { transactionType = TT_MAIN2REMOTE; }
            }
         }
			// do we have a transaction to process?
         if (transactionType != TT_NONE)
         {  // setup to process a transaction request
            mainStation = transTypeInfo[transactionType][TT_MAINSTATION];
            main2main_trans = transTypeInfo[transactionType][TT_MAIN2MAIN_TRANS];
            system_direction = transTypeInfo[transactionType][TT_SYSTEM_DIRECTION];
            systemStationb = station2bit(systemStation);
            inUse(FLASH, systemStationb);
            new_state=PREPARE_SEND;
            arrivalEnable(OFF); // make sure we clear every time
            if ((transactionType == TT_MAIN2SLAVE) || (transactionType == TT_REMOTE2SLAVE)) destMain=SLAVE;
            // leaving this s
         }
         else // check for directory display
         {  k=di_requestToSend;
            if (k & STATION_SET)
            {  systemStationb=k;
               systemStation=bit2station(systemStationb);
               if (systemStation)
                  message_add(TRANSLCD, MSG_REMOTESTA, MSG_AT+systemStation, ONESHOT);
            }
            // nothing else to do here so reset systemStation
            systemStation=0;
            systemStationb=0;
         }

         FirstXtraCic=TRUE;   // Used in HOLD_TRANSACTION
         // when leaving this state blank out the menu buttons and reset screensaver
         if (new_state != system_state)
         {  lcd_drawScreen(1,lcd_NO_BUTTONS);
				lcd_screenSaver(LCD_BRIGHT);
         }
         break;


      case PREPARE_SEND:      // does job for send and return
	      transProgress=10;  	// % progress
         // turn off priority if it was on
         // priority = FALSE; TURN OFF LATER (v2.47)
         message_add(SYSTEMLCD, MSG_SYSBUSY, MSG_DONTUSE, NEXT);
         message_del(SYSTEMLCD, MSG_PRIORITY, MSG_PRIORITY+1);
         do_alert(OFF);
         do_priorityLight(OFF);

         message_add(TRANSLCD, MSG_SETTING, MSG_TO+systemStation, NOW);

         // save transaction data
         translog.start_tm = SEC_TIMER;
         translog.end_tm = 0;
         translog.source_sta=mainStation;
         translog.dest_sta=mainStation;
         if (priority) translog.flags |= FLAG_STAT; //0x10;
         if (system_direction==DIR_SEND) translog.dest_sta=systemStation;
         else translog.source_sta=systemStation;
         if (transactionType == TT_SLAVE2MAIN) translog.dest_sta=MASTER;

         // tell all system(s) to get ready (set diverters)
         set_diverter(systemStation);
         command.devAddr=ALL_DEVICES;
         command.command=SET_DIVERTER;
         command.station=systemStation;
			command.data[0]=transTypeInfo[transactionType][TT_FROM];  // For head diverter
			command.data[1]=mainStation;  // For slave
         command.data[3]=0xFF;  // to help ident main messages
         command.data[4]=0xFF;  // to help ident main messages
         received=send_command(command);
         if (received) new_state=WAIT_FOR_DIVERTERS;
         else new_state=CANCEL_STATE;
         break;

      case WAIT_FOR_DIVERTERS:   // does job for send and return
	      transProgress=20;  	// % progress
	      if (divertersReady(systemStation, transTypeInfo[transactionType][TT_FROM], mainStation))
	      {  new_state=BEGIN_SEND;    // serves both directions
	        if ((system_direction==DIR_SEND) && (main2main_trans==0))
	        {  message_add(TRANSLCD, MSG_INROUTE, MSG_TO+systemStation, NOW);
	        }else if (system_direction==DIR_RETURN && main2main_trans==0)
	        {  message_add(TRANSLCD, MSG_INROUTE, MSG_FROM+systemStation, NOW);
	        }else if (main2main_trans==DIR_SEND)
	        {  message_add(TRANSLCD, MSG_INROUTE, MSG_TO+SLAVE, NOW);
	        } else
	        {  message_add(TRANSLCD, MSG_INROUTE, MSG_TO, NOW);
	        }
	        message_del(TRANSLCD, MSG_SETTING, MSG_TO+systemStation);
	      }
	      else
	      {  // only wait for a little time
	       if (MS_TIMER-state_timer >= DIVERTER_TIMEOUT)
	       {  // timeout
	         statistics.divert_alarm++;
	         new_state=MALFUNCTION_STATE;
	         translog.status=STS_DIVERTER_TOUT; translog.end_tm=SEC_TIMER;
	         message_add(TRANSLCD, MSG_TIMEOUT, MSG_SETTING, NEXT);
	       }
	      }

         // while waiting, if different request to send, cancel.
         if (di_requestToSend
            && (systemStationb != di_requestToSend)
            && (system_direction==DIR_SEND))
               new_state=CANCEL_STATE;

         break;

      case BEGIN_SEND:          // works for both directions
	      transProgress=30;  	// % progress
         // remote should be ready now, but set timeout just in case
         if (MS_TIMER-state_timer >= 2000)
         {  new_state=MALFUNCTION_STATE;   // Remote not ready or cancel dispatch
            translog.status=STS_TRANS_CANCEL; translog.end_tm=SEC_TIMER;
         }

         // before sending start command double check for cic/stacking
         command.data[0]=FALSE;
	      if (system_direction==DIR_SEND && main2main_trans==0)
	      { // main to remote -- check remote carrier or remote stacking
	         if ( !(remote_data[REMOTE_CIC] & systemStationb) || param.stacking_ok[1] ) command.data[0]=TRUE; // ok to continue
         } else if (system_direction==DIR_SEND && main2main_trans==DIR_SEND)
         {  // main to slave
		      if ( param.stacking_ok[0] || !carrierInChamber(SLAVE)) command.data[0]=TRUE;  // ok to continue
         } else if (system_direction==DIR_SEND && main2main_trans==DIR_RETURN)
         {  // slave to main
		      if ( param.stacking_ok[0] || !carrierInChamber(MASTER)) command.data[0]=TRUE;  // ok to continue
	      } else
         { // all other cases check main carrier or main stacking (master or slave)
		      if ( param.stacking_ok[0] || !carrierInChamber(mainStation)) command.data[0]=TRUE;  // ok to continue
	      }

         // are we ok to send?
         if (command.data[0] == TRUE)
         {
            // make sure remotes are ready
            command.devAddr=ALL_DEVICES;
            command.command=ARE_YOU_READY;
            command.station=systemStation;
            command.data[0]=system_direction;
            command.data[1]=mainStation;
            command.data[2]=main2main_trans;
            if (send_n_get(command, &response))
            {
               // if ((response.data[0] & STATION_SET) == STATION_SET)  // all stations ok?
               if (response.data[0] == availableDevices)  // all stations ok?
               {
                  // turn on blower
                  inUse(ON, systemStationb);
                  message_del(TRANSLCD, MSG_REMOTESTA, MSG_NOT_READY);
                  if (system_direction==DIR_SEND)
                  {  if (carrierInChamber(mainStation))
                     {  //blower(blowerSend);
                        new_state=WAIT_FOR_MAIN_DEPART;
                     }else
                     {  print_event("TRANSACTION CANCELED - CARRIER REMOVED");
                        print_transaction( translog );
				            addTransaction( translog );
                        new_state=CANCEL_STATE;
                     }
                  }else
                  {  if (remote_data[REMOTE_CIC] & systemStationb)
                     {  //blower(blowerReturn);
                        new_state=WAIT_FOR_REM_DEPART;
                     }else
                     {  print_event("TRANSACTION CANCELED - CARRIER REMOVED");
                        print_transaction( translog );
				            addTransaction( translog );
                        new_state=CANCEL_STATE;
                     }
                  }
               } else
               {  // remote door?
                  message_add(TRANSLCD, MSG_REMOTESTA, MSG_NOT_READY, NOW);
                  print_event("STATION(S) NOT READY FOR DISPATCH");
                  new_state=CANCEL_STATE;
               }
            }
         } else new_state=CANCEL_STATE;  // no stacking allowed
         break;

      case WAIT_FOR_MAIN_DEPART:
         // check for doors opening
         new_state=checkDoorWhileRunning(system_state);

         // wait for carrier to exit
         if (carrierInChamber(mainStation))
         {
            if (MS_TIMER-state_timer >= CIC_EXIT_TIMEOUT)
            {  // been waiting too long, cancel
               statistics.cic_lift_alarm++;
               translog.status=STS_DEPART_TOUT; translog.end_tm=SEC_TIMER;
               print_malfunction( translog );
				   addTransaction( translog );
               new_state=CANCEL_STATE;
            } // else, keep waiting
         } else
         {
            if (param.headDiverter==TRUE) new_state=WAIT_FOR_HEADDIVERTER;
            else new_state=WAIT_FOR_REM_ARRIVE;
		      transProgress=40;  	// % progress
         }

         break;

      case WAIT_FOR_REM_ARRIVE:
       // keep polling remote status until received, or timeout
       if (remote_data[REMOTE_ARRIVE] & 0x7F) // at any station 1-7 (exclude headdiverter)
       {
          //blower(OFF);
          inUse(OFF, systemStationb);
          message_del(TRANSLCD, MSG_INROUTE, MSG_TO+systemStation);
          message_del(SYSTEMLCD, MSG_SYSBUSY, MSG_DONTUSE);
          arrival_alert |= systemStationb;        // set arrival

          // print transaction data
          statistics.trans_out++;
          translog.end_tm = SEC_TIMER;
          if (printlog_active) print_transaction(translog);
          addTransaction( translog );

          // notify destination of completion
          finalcmd.command=TRANS_COMPLETE;
          finalcmd.station=systemStation;
          finalcmd.data[0]=DIR_SEND;
          // check if (stat alert is active) or (alert always)
          if ( (priority==TRUE) || (param.remote_arrive_alert==TRUE) )
          {
             finalcmd.data[1]=1;
          } else {
             finalcmd.data[1]=0;
          }
          new_state=FINAL_COMMAND;
          systemStation=0;
          systemStationb=0;
 	       transProgress=90;  	// % progress
       } else
       {

			// check for doors opening
	      new_state=checkDoorWhileRunning(system_state);

	      // Check for timeout
	      //if (MS_TIMER-state_timer >= DELIVER_TIMEOUT)
	      if (SEC_TIMER-translog.start_tm > param.deliveryTimeout + doorOpenTimer)
	      {  message_add(TRANSLCD, MSG_ODUE, MSG_TO+systemStation, NEXT);
	        new_state=MALFUNCTION_STATE;
	        statistics.deliv_alarm++;
	        translog.status=STS_ARRIVE_TOUT; translog.end_tm=SEC_TIMER;
	        //blower(OFF);
	      }
       }
        break;

      case WAIT_FOR_REM_DEPART:
       transProgress=40;  	// % progress
       // check for doors opening
       new_state=checkDoorWhileRunning(system_state);

       // wait for carrier to exit
       if (MS_TIMER-state_timer >= CIC_EXIT_TIMEOUT)
       {  // been waiting too long, cancel
          statistics.cic_lift_alarm++;
          //blower(OFF);
          translog.status=STS_DEPART_TOUT; translog.end_tm=SEC_TIMER;
          print_malfunction( translog );
			 addTransaction( translog );
          new_state=CANCEL_STATE;
       }

       if (~remote_data[REMOTE_CIC] & systemStationb)
       {
          if (param.headDiverter==TRUE) new_state=WAIT_FOR_HEADDIVERTER;
          else
          {   new_state=WAIT_FOR_MAIN_ARRIVE;
              if (destMain == MASTER) arrivalEnable(ON);      // enable arrival interrupt
          }
       }

       break;

      case WAIT_FOR_HEADDIVERTER:
       // check for doors opening
       new_state=checkDoorWhileRunning(system_state);

       // wait for arrival at headdiverter controller
	      if (remote_data[REMOTE_ARRIVE] & HEADDIVERTERSTATION) // at headdiverter
	      {
	         // shift headdiverter diverter
	         message_add(TRANSLCD, MSG_SETTING, MSG_TO+systemStation, NOW);
	         // tell all system(s) to get ready (set diverters)
	         set_diverter(systemStation);
	         command.devAddr=ALL_DEVICES;
	         command.command=SET_DIVERTER;
	         command.station=systemStation;
				command.data[0]=transTypeInfo[transactionType][TT_TO];  // For head diverter
				command.data[1]=mainStation;  // For slave??
	         received=send_command(command);
	         if (received) new_state=SHIFT_HEADDIVERTER;
	         else new_state=CANCEL_STATE;
	      }

       // check for timeout
         if (SEC_TIMER-translog.start_tm > param.deliveryTimeout + doorOpenTimer)
         {  message_add(TRANSLCD, MSG_ODUE, MSG_AT+systemStation, NEXT);
            statistics.deliv_alarm++;
            new_state=MALFUNCTION_STATE;
            translog.status=STS_ARRIVE_TOUT; translog.end_tm=SEC_TIMER;
            //blower(OFF);
         }

       break;

      case SHIFT_HEADDIVERTER:
	      transProgress=50;  	// % progress
        // wait for headdiverter diverter to be set
        // check for timeout
       if (MS_TIMER-state_timer >= DIVERTER_TIMEOUT)
       {  // timeout
         statistics.divert_alarm++;
         new_state=MALFUNCTION_STATE;
         translog.status=STS_DIVERTER_TOUT; translog.end_tm=SEC_TIMER;
         message_add(TRANSLCD, MSG_TIMEOUT, MSG_SETTING, NEXT);
       }

       // wait for headdiverter diverter to be set
       if (divertersReady(systemStation, transTypeInfo[transactionType][TT_TO], mainStation))
        {  // new_state=WAIT_FOR_xxx_ARRIVE;    // serves both directions
           if ((system_direction==DIR_SEND) && (main2main_trans == 0))
           {  // message_add(TRANSLCD, MSG_INROUTE, MSG_TO+systemStation, NOW);
              new_state=WAIT_FOR_REM_ARRIVE;
           }else
           {  // message_add(TRANSLCD, MSG_INROUTE, MSG_FROM+systemStation, NOW);
              if (destMain == MASTER) arrivalEnable(ON);      // enable arrival interrupt
              new_state=WAIT_FOR_MAIN_ARRIVE;
           }
	        transProgress=60;  	// % progress

           message_del(TRANSLCD, MSG_SETTING, MSG_TO+systemStation);
        }

       break;

      case WAIT_FOR_MAIN_ARRIVE:

         // check for doors opening
         new_state=checkDoorWhileRunning(system_state);

         // Check for timeout
         //if (MS_TIMER-state_timer >= DELIVER_TIMEOUT)
         if (SEC_TIMER-translog.start_tm > param.deliveryTimeout + doorOpenTimer)
         {  message_add(TRANSLCD, MSG_ODUE, MSG_FROM+systemStation, NEXT);
            statistics.deliv_alarm++;
            new_state=MALFUNCTION_STATE;
            translog.status=STS_ARRIVE_TOUT; translog.end_tm=SEC_TIMER;
         }

         // if tube arrived ...
         if (carrierArrival(destMain) || latchCarrierArrival)
         {
            inUse(OFF, systemStationb);
            arrivalEnable(OFF);      // disable arrival interrupt
            message_del(TRANSLCD, MSG_INROUTE, MSG_FROM+systemStation);
            message_del(TRANSLCD, MSG_INROUTE, MSG_TO+destMain);
            if (destMain==MASTER) main_arrival=SEC_TIMER;   // set equal to current time
            else slave_arrival=SEC_TIMER;
            //lcd_smartPrompt(3); // remove CIC
            arrival_from|=systemStationb;
            message_add(SYSTEMLCD, MSG_ARVALRT, MSG_AT+destMain, NEXT);
            message_del(SYSTEMLCD, MSG_SYSBUSY, MSG_DONTUSE);

            // print transaction data
            statistics.trans_in++;
            translog.end_tm = SEC_TIMER;
            if (printlog_active) print_transaction(translog);
            addTransaction( translog );

            // notify destination of completion
            finalcmd.command=TRANS_COMPLETE;
            finalcmd.station=systemStation;
            finalcmd.data[0]=DIR_RETURN;
	         finalcmd.data[1]=0; // no remote alert
	         finalcmd.data[2]=mainStation;
            new_state=FINAL_COMMAND;
            systemStation=0;
            systemStationb=0;
		      transProgress=90;  	// % progress
         }

         break;

      case HOLD_TRANSACTION:      // serves both send and return
       // restore send when both doors close
       if ((remote_data[REMOTE_DOOR] & systemStationb) && doorClosed(mainStation) && doorClosed(destMain))
       {
          // check if user inserted a new carrier while the door was open
          XtraCic = FALSE;
          if ((memory_state == WAIT_FOR_REM_ARRIVE) && carrierInChamber(mainStation)) XtraCic = TRUE;
          if ((memory_state == WAIT_FOR_MAIN_ARRIVE) && (remote_data[REMOTE_CIC] & systemStationb)) XtraCic = TRUE;
          if  (memory_state == WAIT_FOR_HEADDIVERTER)
          {  if ((system_direction == DIR_SEND) && carrierInChamber(mainStation)) XtraCic = TRUE;
             if ((system_direction == DIR_RETURN) && (remote_data[REMOTE_CIC] & systemStationb)) XtraCic = TRUE;
          }
          if (XtraCic)
          {
            // stay in the alert/alarm mode
            if (FirstXtraCic)
            {  print_event("EXTRA CARRIER INSERTED IN CHAMBER IN TRANSACTION FROM SOURCE");
               FirstXtraCic=FALSE;
               eventlog.flags |= EFLAG_EXTRA_CIC;
            }
          } else
          {
             new_state=memory_state;
             do_alert(OFF);
             // Turn off remote alert
             command.devAddr=ALL_DEVICES;
             command.command=SET_OUTPUTS;
             command.station=systemStation;
             command.data[devInUseSolid]=0;
             command.data[devInUseFlash]=0;
             command.data[devAlert]=0;
             command.data[devAlarm]=0;
             send_command(command);
             print_event("TRANSACTION RESUMED");
             FirstXtraCic=TRUE;
             doorOpenTimer += ((MS_TIMER - state_timer)/1000); // door open timer in seconds
             // capture and log event information
             eventlog.end_tm=SEC_TIMER;
				 addTransaction( eventlog );  // transaction resumed, log the event

          }
       }
       else
       {  // otherwise toggle alert on 2 off 5
          if (((MS_TIMER-state_timer) % 7) >= 2) do_alert(OFF);
          else do_alert(ON);
       }

       // Check for timeout
       //if (MS_TIMER-state_timer >= DELIVER_TIMEOUT)
/* v327: don't timeout a transaction while the door is open (UNLESS ITS A REALLY LONG TIME???)
       if (SEC_TIMER-translog.start_tm > param.deliveryTimeout + doorOpenTimer)
       {  new_state=MALFUNCTION_STATE;
          statistics.deliv_alarm++;
          translog.flags|=3; translog.end_tm=SEC_TIMER;
       }
*/
       break;


      case CANCEL_STATE:
	      // reset all outputs and return to normal
	      inUse(OFF, systemStationb);
	      do_alert(OFF);
	      alarm(OFF);
	      arrivalEnable(OFF);      // disable arrival interrupt
			alarm_sound_flag=TRUE;   // reset alarm sound for next alarm
        // clear lcd message buffer unless just starting up
        if (systemStartup==FALSE)
	     {  message_del(SYSTEMLCD, EMPTY, EMPTY);
   	     message_del(TRANSLCD, EMPTY, EMPTY);
        }

        finalcmd.command=RESET;
        finalcmd.station=0;
        new_state=FINAL_COMMAND;
        systemStation=0;
        systemStationb=0;
        malfunctionActive=FALSE;

        // turn off priority if it was on
        priority = FALSE;
        break;

      case MALFUNCTION_STATE:
        if (malfunctionActive==FALSE)
        {
           inUse(OFF, ALL_STATIONS);
           do_alert(OFF);
           print_malfunction( translog );
           addTransaction( translog );
           lcd_drawScreen(1,lcd_WITH_BUTTONS); // redraw screen with buttons to allow for alarm mode
        }
        arrivalEnable(OFF);      // disable arrival interrupt
        if (mainStation == MASTER) alarm(ON);
        // turn off priority if it was on
        priority = FALSE;
        // signal alarm at remote
        command.devAddr=ALL_DEVICES;
        command.command=MALFUNCTION;
        command.station=systemStation;
        send_command(command);

        // put up lcd message
        message_add(SYSTEMLCD, MSG_ALARM, MSG_ALARM+1, NOW);
        malfunctionActive=TRUE;

        break;

      case FINAL_COMMAND:
         // set the command before entering this state
         // remains in this state until command received or timeout
         //if (systemStartup==FALSE) transProgress=999;  // blank out progress bar
         //else transProgress=101; // don't blank progress bar
         finalcmd.devAddr=ALL_DEVICES;
         if (send_command(finalcmd))
         {
            new_state=IDLE_STATE;
            if (finalcmd.command==TRANS_COMPLETE) incrementCounter();
            // turn off priority if it was on
            priority = FALSE;
            transProgress=101; // don't blank progress bar
            if (systemStartup==FALSE) lcd_drawScreen(1,lcd_WITH_BUTTONS);  // Redraw screen with buttons
		      systemStartup=FALSE;  // no longer in system startup mode
         }

         // check timeout
         if (MS_TIMER-state_timer >= 1000)
         {  new_state=IDLE_STATE;
         	if (systemStartup==FALSE) lcd_drawScreen(1,lcd_WITH_BUTTONS);  // Redraw screen with buttons
		      systemStartup=FALSE;  // no longer in system startup mode
			}
         break;

      default:
         // unknown state, execute cancel code
         new_state=CANCEL_STATE;
   }

   // if state change, reset state timer
   if (new_state != system_state)
   {
      // set blower for new state
      blower(blowerStateTable[new_state][blwrConfig]);
      state_timer=MS_TIMER;
      system_state=new_state;
      first_time_here=TRUE;    // wasn't here yet
   }
   else first_time_here=FALSE; // were already here


}

char checkDoorWhileRunning(char calling_state)
{  // Check for main or remote doors opening
   struct iomessage command;
   char event_string[80];     // line to send to the printer
   char rtnval;

   rtnval = calling_state;  // return same state by default

   // check for main station door opening
   if ((!doorClosed(mainStation)) || (!doorClosed(destMain)))
   {
	   do_alert(ON);
	   rtnval=HOLD_TRANSACTION;
	   memory_state=calling_state;
	   strcpy(event_string, "DOOR OPEN IN TRANSACTION (#) ");
      event_string[26] = 97+calling_state;
	   strcat(event_string, sys_message[MSG_AT+mainStation].msg);
	   print_event(event_string);
      eventlog.start_tm=SEC_TIMER;
      eventlog.source_sta=mainStation;
      eventlog.dest_sta=calling_state;
      eventlog.status=ESTS_DOOROPEN;
      eventlog.flags|=EFLAG_MAINDOOR;

      //st_time_diff = MS_TIMER - st_timer; // hold transfer timeout
      //message_add(SYSTEMLCD, MSG_SYSALARM, MSG_DOOR_OPEN, NOW);
      //door_warning = TRUE;
   }
   // check for remote station door opening
   if (~remote_data[REMOTE_DOOR] & systemStationb)
   {
      do_alert(ON);
      // Turn on remote alert
      command.devAddr=ALL_DEVICES;
      command.command=SET_OUTPUTS;
      command.station=systemStation;
      command.data[devInUseSolid]=0;
      command.data[devInUseFlash]=0;
      command.data[devAlert]=systemStationb;
      command.data[devAlarm]=0;
      send_command(command);
      rtnval=HOLD_TRANSACTION;
      memory_state=calling_state;
      strcpy(event_string, "DOOR OPEN IN TRANSACTION (#) ");
      event_string[26] = 97+calling_state;
      strcat(event_string, sys_message[MSG_AT+systemStation].msg);
      print_event(event_string);
      // capture event information
      eventlog.start_tm=SEC_TIMER;
      eventlog.source_sta=systemStation;
      eventlog.dest_sta=calling_state;
      eventlog.status=ESTS_DOOROPEN;
      eventlog.flags|=EFLAG_SUBSDOOR;

      //st_time_diff = MS_TIMER - st_timer; // hold transfer timeout
      //message_add(SYSTEMLCD, MSG_SYSALARM, MSG_DOOR_OPEN, NOW);
      //door_warning = TRUE;
   }

   return rtnval;
}

void processMainArrivalAlert(void)
{
	// clear main arrival alert when door opens and no more carrier
	if (main_arrival)
	{
	   // check for 10 second arrival alert signal
	   if ( (SEC_TIMER - main_arrival) %20 >= 10 ) do_alert(ON);
	   else                                        do_alert(OFF);

	   // check to clear main arrival alert
	   if (!di_doorClosed && !di_carrierInChamber)
	   {  main_arrival=0;
	      arrival_from=0;
	      message_del(SYSTEMLCD, MSG_ARVALRT, MSG_AT);
	      do_alert(OFF);
	      latchCarrierArrival=FALSE;    // clear latch
         //lcd_smartPrompt(0); // clear smartPrompt
	   }
	}
}

void processStatPriority(void)
{  // use btnStatFlag to communicate between lcd screen functions and here
   // btnStatFlag = 1 - turn on stat
   // btnStatFlag = 2 - turn off stat
   //             = else - no change

   // activate priority (next transaction) if requested
   if (di_priorityRequest || (btnStatFlag==1))
   {  priority = TRUE;
      btnStatFlag = 0;
      priority_seconds = SEC_TIMER + PRIORITY_TIMEOUT;
      do_priorityLight(ON);
      message_add(SYSTEMLCD, MSG_PRIORITY, MSG_PRIORITY+1, NOW);
   }
   // deactivate priority after timeout, if not in a transaction
   if ((priority && (SEC_TIMER > priority_seconds) && (system_state == IDLE_STATE)) || btnStatFlag==2)
   {  priority = FALSE;
      btnStatFlag = 0;
      do_priorityLight(OFF);
      // deactivate screen button
      lcd_SetState( BTN_STAT, 0);
      message_del(SYSTEMLCD, MSG_PRIORITY, MSG_PRIORITY+1);
   }
}

char processKeyInput()
{  // DON'T USE THIS FUNCTION!!!!!

}

void showactivity()
{
   // update active processor signal
   ledOut(0, (MS_TIMER %500) < 250);  // on fixed frequency
   ledOut(1, (MS_TIMER %500) > 250);  // off fixed frequency
   toggleLED(2);                      // toggle each call
}
void toggleLED(char LEDDev)
{
   static char LEDState[4];

   // initialize LED states off
   #GLOBAL_INIT
   {  LEDState[0]=0; LEDState[1]=0; LEDState[2]=0; LEDState[3]=0;
   }

   LEDState[LEDDev] ^= 1;               // toggle LED state on/off
   ledOut(LEDDev, LEDState[LEDDev]);    // send LED state

}

/******************************************************************/
// Blower Processing Routines
/******************************************************************/
// Interface definition
// char blwrConfig;     // to become a parameter from eeprom
// blwrConfig 0 = Standard blower
// blwrConfig 1 = High capacity APU blower
// #define blwrOFF  0
// #define blwrIDLE 1
// #define blwrVAC  2
// #define blwrPRS  3
//// void init_blower(void);
// void blower(char blowerOperatingValue);  // use blwrOFF, blwrIDLE, blwrVAC, blwrPRS
// char processBlower(void);
// char blowerPosition(void);

char processBlower()
{}

char blowerPosition()
{}

void blower(char request)
{
   /* if on_request and already on opposite direction, turn off first */
   // Invert logic on output bits, now output bit 0 = off per v2.34.1
   char how;
   static char lastHow;

   #GLOBAL_INIT
   {  lastHow = 0;
		blwrConfig = 0; // Later to become eeprom parameter
   }

   how = request;

   // make sure correct parameter is used.  anything but VAC and PRS is OFF
   if ((how != blwrVAC) && (how != blwrPRS)) how = blwrOFF;

   // if going from one on-state to the other on-state then turn off first
   if ((how != blwrOFF) && (lastHow != blwrOFF) && (how != lastHow))
   {  // can't run in both directions at the same time
      do_blowerPRS(OFF);
      do_blowerVAC(OFF);
      msDelay(100);                   /* wait a little while */
   }

   /* turn on appropriate bit */
   if (how == blwrPRS)      do_blowerPRS(ON);
   else if (how == blwrVAC) do_blowerVAC(ON);
   else { do_blowerPRS(OFF);
          do_blowerVAC(OFF);
        }

   // remember last setting
   lastHow = how;

   return;
}
// DIVERTER PROCESSING ROUTINES
void setDiverterConfiguration()
{
   // diverter configuration set by localDiverter byte
   // 0 = no local diverter; 1 = local diverter;

   // sets up values in the diverter_map station array
   // Array index is station # 1..7;
   // Value is diverter address; leg 1 or 2 or 0=n/a

   if (param.localDiverter == 0)
   {  // All stations n/a
      diverter_map[0] = 0; diverter_map[1] = 0;
      diverter_map[2] = 0; diverter_map[3] = 0;
      diverter_map[4] = 0; diverter_map[5] = 0;
      diverter_map[6] = 0; diverter_map[7] = 0;
      diverter_map[8] = 0;

   } else {
      // Station 1..4 on diverter leg 1;   5..7 on leg 2
      diverter_map[0] = 0; diverter_map[1] = 1;
      diverter_map[2] = 1; diverter_map[3] = 1;
      diverter_map[4] = 1; diverter_map[5] = 2;
      diverter_map[6] = 2; diverter_map[7] = 2;
      diverter_map[8] = 0;  // no local diverter for slave
   }
}
/******************************************************************/
char divertersReady(char station, char headDiverter, char mainDiverter)
{  // Indicates if all local and remote diverters are set to
   // the specified station position.  Returns TRUE or FALSE.

   struct iomessage command, response;
   char rtnval;

   rtnval=FALSE;   // assign default value
   command.devAddr=ALL_DEVICES;
   command.command=DIVERTER_STATUS;
   command.station=station;
   command.data[0]=headDiverter;
   command.data[1]=mainDiverter;
   response.data[0]=0;
   send_n_get(command, &response);
   //if ( ( (response.data[0] & STATION_SET)==STATION_SET)
   if ( (response.data[0]==availableDevices)
       && ( (di_diverterPos==diverter_map[station])
             || (diverter_map[station]==0) ) )
   {   rtnval=TRUE;  }

   return rtnval;
}
/******************************************************************/
void set_diverter(char station)
{  /* Controls the setting of diverter positions
      Return from this routine is immediate.  If diverter is not
      in position, it is turned on and a timer started.

      You MUST repeatedly call check_diverter() to complete processing
      of the diverter control position
   */

   /* use mapping from station to diverter position */

   if ((station>0) && (station<9))     // Valid station #
   {
      diverter_setting = diverter_map[station];    // mapped setting

      // if position<>ANY (any=0) and not in position
      if ((diverter_setting>0) && (diverter_setting!=di_diverterPos))
      {
         /* turn on diverter and start timer */
         do_diverter(ON);
         diverter_start_time = MS_TIMER + DIVERTER_TIMEOUT;
         diverter_attention = TRUE;
         // NOT USED IN MAIN diverter_station=station;
      }
   }
   return;
}
/******************************************************************/
void check_diverter()
{  /* Poll type processing of diverter control system */
   /* Allows other processes to be acknowleged when setting diverter */

   if (diverter_attention)
   {
      if ((diverter_setting == di_diverterPos) || (MS_TIMER-diverter_start_time > DIVERTER_TIMEOUT))
      {
         // turn off diverter and clear status
         do_diverter(OFF);
         diverter_attention = FALSE;
         // NOT USED IN MAIN: diverter_station=0;
      }
   }
}

//**************************************
//   DIGITAL INPUT/OUTPUT FUNCTIONS
//**************************************
int readDigInput(char channel)
{  // returns the state of digital input 0-39
   // function supports inverted logic by assigning dio_ON and dio_OFF

   char rtnval;

   if (channel < 16)
   {  // on-board inputs
      rtnval = digIn(channel);
   }
   else
   {  // rn1100 inputs
      if (DevRN1100 != -1)
      { if (rn_digIn(DevRN1100, channel-16, &rtnval, 0) == -1) rtnval=0; }
      else rtnval = 0;
   }
   // deal with logic inversion
   if (rtnval) rtnval = dio_ON;
   else        rtnval = dio_OFF;
   return rtnval;
}

void setDigOutput(int channel, int value)
{  // sets the state of digital output 0-23
   // call with logic value (0=OFF, 1=ON)
   // function is adapted to support inverted logic by assigning dio_ON and dio_OFF

   int outval;
   // check for logic inversion
   if (value) outval = dio_ON;
   else       outval = dio_OFF;

   if (channel < 8)
   {  // on-board outputs
      digOut(channel, outval);
   }
   else
   {  // rn1100 outputs
      if (DevRN1100 != -1)
         rn_digOut(DevRN1100, channel-8, outval, 0);
   }
}
void alarm(char how)
{
   if (how)
   {  // turn on light
      do_alarmLight(how);
      // if sound flag on, turn noise on, else off.
      if (alarm_sound_flag) do_alarmSound(how);
      else do_alarmSound(OFF);
   }
   else
   {  // turn off light and sound
      do_alarmSound(how);
      do_alarmLight(how);
   }

   return;
}

void inUse(char how, char station_b)
{	// Only sets the global flags
   // Call Maintenance to actually turn on/off lights

   if (how == ON)
   {  /* solid on, flash off */
      outputvalue[devInUseSolid] |= station_b & STATION_SET;
      outputvalue[devInUseFlash] &= ~(station_b & STATION_SET);
   }
   else if (how == OFF)
   {  /* solid off, flash off */
      outputvalue[devInUseSolid] &= ~(station_b & STATION_SET);
      outputvalue[devInUseFlash] &= ~(station_b & STATION_SET);
   }
   else if (how == FLASH)
   {  /* solid off, flash on */
      outputvalue[devInUseSolid] &= ~(station_b & STATION_SET);
      outputvalue[devInUseFlash] |= station_b & STATION_SET;
   }

   return;
}
// define input functions which take master/slave as a parameter
char carrierInChamber(char whichMain)
{	if (whichMain==MASTER) return di_carrierInChamber;
	else return slaveData[0] & 0x01;
}
char carrierArrival(char whichMain)
{	if (whichMain==MASTER) return di_carrierArrival;
	else return slaveData[0] & 0x04;
}
char doorClosed(char whichMain)
{	if (whichMain==MASTER) return di_doorClosed;
	else return slaveData[0] & 0x02;
}

//**************************************
//   KEYPAD INPUT FUNCTIONS
//**************************************
char getKey(void)
{  // Return a key from the keypad
   char wKey;
   char gk;
   static char last;

   //rn_keyProcess(DevRN1600, 0);  // process keypad device
   //wKey = rn_keyGet(DevRN1600, 0);
   // reset menu timeout every time a key is pressed
   if (wKey) menu_timeout=SEC_TIMER + 60;
   else
   {  // no keypad key so look for request-to-send key
	   gk = bit2station(di_requestToSend);
      // return the key when the button is released
	   if (gk==0 && last!=0)
	   {  wKey=last;
	      last=0;
	      menu_timeout=SEC_TIMER + 60;
	   } else
	   {  last=gk;
	   }
   }
   return wKey;
}

char valid_send_request(char station_b)
{
   char ecode, stanum;
   stanum = bit2station(station_b);
   if (stanum > 0)
   {
      /* make sure local inputs are correct */
      if (di_carrierInChamber && di_doorClosed)
      {
        ecode=0;    // good request
      } else
      {
        ecode=2;    // door open or no carrier
      }
   } else ecode=1;   // no or multiple inputs

   return ecode;
}

/*******************************************************/
// transaction request queue functions
#define queue_len 4
struct trans_queue_type
{
    char source;
    char dest;
} trans_queue[queue_len];
char queue_last;

void queueAdd(char tsource, char tdest)
{
    // adds request to queue  USE BIT VALUES

    char i;
    char found;

    // add only if source does not already exist .. otherwise replace
    found=FALSE;
    for (i=0; i<queue_len; i++)
    {   if (trans_queue[i].source==tsource)
        { // replace existing entry
          trans_queue[i].dest = tdest;
          found=TRUE;
        }
    }
    if (found==FALSE)
    {  // not found so add after last current entry
       queue_last = (queue_last+1) % queue_len;
       trans_queue[queue_last].source=tsource;
       trans_queue[queue_last].dest=tdest;
    }
}

void queueDel(char tsource, char tdest)
{
    // deletes request from queue
    // call with (0,0) to initialize
    char i;

    if (tsource==0 && tdest==0)
    {  for (i=0; i<queue_len; i++)
       {  trans_queue[i].source=0;
          trans_queue[i].dest=0;
       }
       queue_last=0;
    } else // find specified entry and delete it
    {  for (i=0; i<queue_len; i++)
       {  if (trans_queue[i].source==tsource && trans_queue[i].dest==tdest)
          {   trans_queue[i].source=0;
              trans_queue[i].dest=0;
              // decrement last if it is the current entry
              if (queue_last==i) queue_last = (queue_last+queue_len-1) % queue_len;
          }
       }
    }
}

void queueNext(char *tsource, char *tdest)
{  // returns next queue entry

   char i;
   char found;

   // start at last+1 until a non-zero entry or back to last

   *tsource=0; *tdest=0;   // initialize to zero

   found=FALSE;
   i=queue_last;
   do
   {   // increment to next queue entry
       i=(i+1) % queue_len;
       if (trans_queue[i].source != 0)
       {   // this must be it
           *tsource=trans_queue[i].source;
           *tdest=trans_queue[i].dest;
           found=TRUE;
       }
   } while (found==FALSE && i!=queue_last);
}

char queueVerify(char cic_data, char door_data)
{
    // step through each queue entry and kill if no carrier or door open
    // returns bit set of each station in queue (to flash in-use)

    char i;
    char rtnval;

    rtnval=0;
    for (i=0; i<queue_len; i++)
    { if (trans_queue[i].source != 0)  // if valid queue entry
      {
        if ((trans_queue[i].source & cic_data & door_data) == 0)
        {   // kill it ... no more carrier or door is open
            queueDel(trans_queue[i].source, trans_queue[i].dest);
        } else
        {   // include these bits in return val
            rtnval |= trans_queue[i].source | trans_queue[i].dest;
        }
      }
    }
    return rtnval;
}


//**************************************
//   LCD MESSAGE FUNCTIONS
//**************************************
static unsigned long msgtimer;
struct queue
{  char curentry;
   char cursize;
   char line1[QUEUESIZE];
   char line2[QUEUESIZE];
} msgqueue[2];
char oneshot[2][2];   // oneshot buffer [lcd][line]
char currentmsg[2][2];  // current display message

void message_del(char lcd, char msgline1, char msgline2)
{
   char k, l, loc;

   if ( (lcd != 0) && (lcd != 1) ) return;      // invalid lcd#

   if (msgline1==EMPTY)
   {  // delete all messages, reinitialize queue
      for (l=0; l<LCDCOUNT; l++)
      {
       for (k=0; k<QUEUESIZE; k++)
       {  msgqueue[l].line1[k] = EMPTY;
          msgqueue[l].line2[k] = EMPTY;
       }
       msgqueue[l].curentry = 0;
       msgqueue[l].cursize = 0;
       oneshot[l][0]=EMPTY;    // clear oneshot buffers
       oneshot[l][1]=EMPTY;
      }
      message_show(NOW);
      //
   }
   else
   {  // remove message from queue
      k=0;
      while ( ((msgline1 != msgqueue[lcd].line1[k])
          || ( (msgline2 != msgqueue[lcd].line2[k])
          || (msgline2 == EMPTY) ))
          && (k < QUEUESIZE-1) ) k++;

      if ( (msgline1 == msgqueue[lcd].line1[k])
       && ( (msgline2 == msgqueue[lcd].line2[k])
       || (msgline2 == EMPTY) ) )
      {
       loc = k;
       for (k=loc; k<QUEUESIZE-1; k++)
       {  msgqueue[lcd].line1[k] = msgqueue[lcd].line1[k+1];
          msgqueue[lcd].line2[k] = msgqueue[lcd].line2[k+1];
       }
       msgqueue[lcd].cursize--;                  // decrement current size
       if (msgqueue[lcd].cursize==0) msgqueue[lcd].curentry=0;
       msgqueue[lcd].line1[QUEUESIZE-1] = EMPTY; // insert empty entry at end
       if (msgqueue[lcd].line1[ msgqueue[lcd].curentry ] == EMPTY)
       {
          msgqueue[lcd].curentry = 0;
          message_show(NOW);   // show next
       }
       if (msgqueue[lcd].curentry == loc)
          message_show(NOW);   // show next
      }
   }
   return;
}

void message_add(char lcd, char msgline1, char msgline2, char how)
{  int k;
   // how = NOW       // show message immediately
   // how = NEXT      // show message next
   // how = ONESHOTA  // show message once first of 2 oneshots
   // how = ONESHOT   // show message once right now

   if ( (lcd != 0) && (lcd != 1) ) return;      // invalid lcd#

   if (how==ONESHOT || how==ONESHOTA)
   {  // show only once
      oneshot[lcd][0]=msgline1;
      oneshot[lcd][1]=msgline2;
      if (how==ONESHOT) message_show(ONESHOT);
      return;
   }

   // insert as next message if not already in queue
   k=0;
   if (msgqueue[lcd].cursize==0)
   {  msgqueue[lcd].curentry=0;
      msgqueue[lcd].line1[0] = msgline1;
      msgqueue[lcd].line2[0] = msgline2;
      msgqueue[lcd].cursize++;
   }
   else
   {
      while ( ( (msgline1 != msgqueue[lcd].line1[k])
       || (msgline2 != msgqueue[lcd].line2[k]) )
          && (k < QUEUESIZE-1) ) k++;
      if ( (msgline1 != msgqueue[lcd].line1[k])
        || (msgline2 != msgqueue[lcd].line2[k]) ) // must not be in q already
      {  for (k=QUEUESIZE-2; k>msgqueue[lcd].curentry; k--)
         {
            msgqueue[lcd].line1[k+1] = msgqueue[lcd].line1[k]; // shift over
            msgqueue[lcd].line2[k+1] = msgqueue[lcd].line2[k]; // shift over
         }
         msgqueue[lcd].line1[ msgqueue[lcd].curentry+1 ] = msgline1;
         msgqueue[lcd].line2[ msgqueue[lcd].curentry+1 ] = msgline2;
         msgqueue[lcd].cursize++;                     // increment current size
      }
      else return;      // no update if already in queue
   }                       // fix queue when size=1 and not current
   if ( (how == NOW ) || ( msgqueue[lcd].cursize==1 ) )
   {  // make current now, otherwise update in time
      message_show(NOW);
   }
   return;
}

void message_show(char how)
{
   char lcd, l1, l2, k;

   if ( (how==NOW) || (how==ONESHOT) || (MS_TIMER - msgtimer >= SCROLLTIME) )
   {  if (how != ONESHOT)
      {
        // index to next message (both lcds)
        for (lcd=0; lcd<LCDCOUNT; lcd++)
        {
          if (msgqueue[lcd].cursize > 0)
          {
             k=msgqueue[lcd].curentry + 1;
             while ((msgqueue[lcd].line1[k] == EMPTY)
                    && (k != msgqueue[lcd].curentry))
                   k=(k+1)%QUEUESIZE;
             if (msgqueue[lcd].line1[k] != EMPTY) msgqueue[lcd].curentry = k;
          }
        }
      }
      msgtimer = MS_TIMER; // + SCROLLTIME;

      // display messages
      for (lcd=0; lcd<LCDCOUNT; lcd++)
      {
        if ((how==ONESHOT) && (oneshot[lcd][0] != EMPTY))
        {
          l1=oneshot[lcd][0];        // use oneshot buffer
          l2=oneshot[lcd][1];
          oneshot[lcd][0]=EMPTY;     // clear oneshot buffer
        } else {                      // load regular message
          l1=msgqueue[lcd].line1[ msgqueue[lcd].curentry ];
          l2=msgqueue[lcd].line2[ msgqueue[lcd].curentry ];
        }

        if (l1==EMPTY)          // show default msg if empty queue
        {  setTimeMessages(MSG_DATE_TIME, SEC_TIMER);  // default uses time message
           if (lcd==TRANSLCD)
           {  l1=MSG_TDEFAULT;
              l2=MSG_TDEFAULT2;
           }
           else
           {  l1=MSG_SDEFAULT;
              l2=MSG_SDEFAULT2;
           }
        }
        // check for timer message refresh before display
        refresh_timer_message(l1);
        refresh_timer_message(l2);

        // double check message range before display
        if ((l1>=0) && (l1<MSGCOUNT))
        {  //lcd_print(lcd, 0, sys_message[l1].msg);
           currentmsg[lcd][0] = l1;
        }
        if ((l2>=0) && (l2<MSGCOUNT))
        {  //lcd_print(lcd, 1, sys_message[l2].msg);
           currentmsg[lcd][1] = l2;
        }
      }
      // send command to remote systems with lcd's to display same msg
      displayRemoteMsgs(&currentmsg[0][0]);
      if (echoLcdToTouchscreen) lcd_displayMsgs(&currentmsg[0][0]);  // color touch screen

      for (lcd=0; lcd<LCDCOUNT; lcd++)
      {
        // show messages after sending to slave
        //lcd_print(lcd, 0, sys_message[currentmsg[lcd][0]].msg);
        //lcd_print(lcd, 1, sys_message[currentmsg[lcd][1]].msg);
        printf("%s\n%s\n", sys_message[currentmsg[lcd][0]].msg, sys_message[currentmsg[lcd][1]].msg);
      }

   }
}
void refresh_timer_message(char msg)
{  // Update display of dynamic messages
   // timer messages need to refresh every second

   char lcd, line;
   unsigned long timepar;

   //switch (msg)
   //{
/*   case MSG_EXPOSE_TIME:
      // count up or count down
      if (op_mode == OPMODE_MANUAL) timepar = (MS_TIMER - exposure_start_time) / 1000;
      else timepar = param.exposureTimer - (MS_TIMER - exposure_start_time)/1000;
      sys_message[MSG_EXPOSE_TIME].msg[9]  = 48 + (sample_number / 10);
      sys_message[MSG_EXPOSE_TIME].msg[10] = 48 + (sample_number % 10);
      setTimeMessages(MSG_EXPOSE_TIME, timepar);
      //lcd_print(lcd, line, sys_message[MSG_EXPOSE_TIME].msg);
      break;
*/
   //}
}

void lcd_show_cursor(char lcd, char line, char pos)
{  // Show or hide the lcd cursor
   if (lcd >= LCDCOUNT)
   {  //rn_dispCursor(DevRN1600, RNDISP_CUROFF, 0);
   } else
   {
      //rn_dispCursor(DevRN1600, RNDISP_CURON, 0);
      //rn_dispGoto (DevRN1600, pos, line+lcd*2, 0);
   }
}
void reset_msg_timer(char how)
{  // setup for next message in time or show next message now (soon)
	if (how==NOW) msgtimer = MS_TIMER + 100 - SCROLLTIME;
   else if (how=NEXT) msgtimer = MS_TIMER;
}
void lcd_print(char lcd, char line, char* message)
{
    lputs(line+lcd*2, message);
}
void lputs(char line, char* msg)
{
   //char c;
   //rn_dispGoto(DevRN1600, 0, line, 0);
   //rn_dispPrintf (DevRN1600, 0, msg);
   //for (c=0; c<MSG_LEN; c++) rn_dispPutc(DevRN1600, msg[c], 0);
	printf("%s \n", msg);
}

void lcd_initialize()
{
}
/******************************************************************/
void initializeMessages(void)
{  // Setup messages for lcd display

   char j;

   // load ram messages with contents of rom
   for (j=0; j<MSGCOUNT; j++)
       strcpy(sys_message[j].msg, sysmsg[j]);

   // set station name messages
   buildStationNames();
}
/******************************************************************/
const char * const defaultStaName[] = { "MAIN", "STATION 1", "STATION 2", "STATION 3",
"STATION 4", "STATION 5", "STATION 6", "STATION 7", "SLAVE MAIN", "SYSTEM" };
void buildStationNames()
{
   char j, k, start, mybuf[17];

   // check if names are initialized
    if (param.names_init != 69)      // init flag
    {
      // use default names
	   for (j=0; j<SYSTEM_NAME; j++)     // SYSTEM_NAME always the last name
	   {
	      strcpy(param.station_name[j].name, defaultStaName[j]);
      }
      param.names_init = 69;
    }

   // build station name messages
   for (j=0; j<SYSTEM_NAME; j++)     // SYSTEM_NAME always the last name
   {
     // clear out destinations
     strcpy(sys_message[MSG_AT+j].msg, sys_message[MSG_BLANK].msg);
     strcpy(sys_message[MSG_FROM+j].msg, sys_message[MSG_BLANK].msg);
     strcpy(sys_message[MSG_TO+j].msg, sys_message[MSG_BLANK].msg);

     strcpy(mybuf, "AT ");
     strcat(mybuf, param.station_name[j].name);
     // center message
     start = (16 - strlen(mybuf)) / 2;
     // place in destination
     for (k=0; k<strlen(mybuf); k++)
          sys_message[MSG_AT+j].msg[k+start]=mybuf[k];

     strcpy(mybuf, "FROM ");
     strcat(mybuf, param.station_name[j].name);
     // center message
     start = (16 - strlen(mybuf)) / 2;
     // place in destination
     for (k=0; k<strlen(mybuf); k++)
          sys_message[MSG_FROM+j].msg[k+start]=mybuf[k];

     strcpy(mybuf, "TO ");
     strcat(mybuf, param.station_name[j].name);
     // center message
     start = (16 - strlen(mybuf)) / 2;
     // place in destination
     for (k=0; k<strlen(mybuf); k++)
          sys_message[MSG_TO+j].msg[k+start]=mybuf[k];

    }
}
char functionDefineStations()
{  // define the active stations
}
/******************************************************************/
void functionSetNames()
{  // edit main & remote station names
}

// time structure used in several of the following routines
//struct tm time;
void setCountMessage(void)
{  // store long numeric value transactionCount into message buffer
   char j, k, mybuf[MSG_LEN+1];
   strcpy(sys_message[MSG_TRANS_COUNT].msg, sys_message[MSG_BLANK].msg);
   ltoa(transactionCount(), mybuf);
   // stuff mybuf into center of message
   k=(MSG_LEN-strlen(mybuf))/2;
   for (j=0; j<strlen(mybuf); j++)
       sys_message[MSG_TRANS_COUNT].msg[j+k]=mybuf[j];
}
void setParValueMessage(char MSG_message, unsigned long par_value, char * par_units)
{  // store long numeric value into message buffer
   char j, k, mybuf[MSG_LEN+1];
   // blank out existing message
   strcpy(sys_message[MSG_message].msg, sys_message[MSG_BLANK].msg);
   // convert value to string and append units text
   ltoa(par_value, mybuf);
   strcat(mybuf, " ");
   strcat(mybuf, par_units);
   // place mybuf and units text into center of message
   k=(MSG_LEN-strlen(mybuf))/2;
   for (j=0; j<strlen(mybuf); j++)
       sys_message[MSG_message].msg[j+k]=mybuf[j];
}
// Define leader offset into messages (0 for 16 char lcd, 2 for 20 char lcd)
#define MSG_OFFSET 0
void setTimeMessages(char message, unsigned long timedate)
{  // fills in the time and date into the sys_message messages
   // timedate in seconds

   struct tm time;
   //char bad;
   //bad=63;  // question mark
   // convert unsigned long to time structure
   mktm(&time, timedate);

   //if ( tm_rd( &time ) )
   //{       // error reading date/time
   //} else
   if (message == MSG_DATE_TIME)
   {
      // fill in the time values
/*    FOR ORIGINAL TIME MESSAGE
      sys_message[MSG_TIME].msg[MSG_OFFSET + 7] = 48 + (time.tm_hour / 10);
      sys_message[MSG_TIME].msg[MSG_OFFSET + 8] = 48 + (time.tm_hour % 10);
      sys_message[MSG_TIME].msg[MSG_OFFSET + 10] = 48 + (time.tm_min / 10);
      sys_message[MSG_TIME].msg[MSG_OFFSET + 11] = 48 + (time.tm_min % 10);
      //sys_message[MSG_TIME].msg[13] = 48 + (time.tm_sec / 10);
      //sys_message[MSG_TIME].msg[14] = 48 + (time.tm_sec % 10);
*/

      // and second message
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 10] = 48 + (time.tm_hour / 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 11] = 48 + (time.tm_hour % 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 13] = 48 + (time.tm_min / 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 14] = 48 + (time.tm_min % 10);

      // fill in the date values
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 7] = 48 + (time.tm_mon / 10);
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 8] = 48 + (time.tm_mon % 10);
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 10] = 48 + (time.tm_mday / 10);
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 11] = 48 + (time.tm_mday % 10);
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 13] = 48 + ((time.tm_year / 10) % 10);
//      sys_message[MSG_DATE].msg[MSG_OFFSET + 14] = 48 + (time.tm_year % 10);

      // and second message
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 1] = 48 + (time.tm_mon / 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 2] = 48 + (time.tm_mon % 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 4] = 48 + (time.tm_mday / 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 5] = 48 + (time.tm_mday % 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 7] = 48 + ((time.tm_year / 10) % 10);
      sys_message[MSG_DATE_TIME].msg[MSG_OFFSET + 8] = 48 + (time.tm_year % 10);
   }
   else if (message == MSG_PAR_VALUE)
   {
      // fill in the time values
      //sys_message[MSG_PAR_VALUE].msg = "    HH:MM:SS    ";
      strcpy(sys_message[MSG_PAR_VALUE].msg, sys_message[MSG_BLANK].msg);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 4] = 48 + (time.tm_hour / 10);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 5] = 48 + (time.tm_hour % 10);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 6] = ':';
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 7] = 48 + (time.tm_min / 10);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 8] = 48 + (time.tm_min % 10);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 9] = ':';
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 10] = 48 + (time.tm_sec / 10);
      sys_message[MSG_PAR_VALUE].msg[MSG_OFFSET + 11] = 48 + (time.tm_sec % 10);
   }

}
void setFlagMessage(char flag)
{
   // flag message is on or off
   if (flag)
   {  sys_message[MSG_FLAG_SET].msg[MSG_OFFSET + 12]=78;          // ON
      sys_message[MSG_FLAG_SET].msg[MSG_OFFSET + 13]=32;
   } else
   {  sys_message[MSG_FLAG_SET].msg[MSG_OFFSET + 12]=70;          // OFF
      sys_message[MSG_FLAG_SET].msg[MSG_OFFSET + 13]=70;
   }
}
void show_extended_data()
{  // display watchdog and powerlow resets on the lcd
   char i;
   char msgbuf[17];
return;
   //lcd_print(SYSTEMLCD, 0, " REMOTE RESETS  ");
   strcpy(msgbuf, "#n WD:___ PL:___");
//   lcd_select(SYSTEMLCD);
   for (i=1; i<8; i++)
   {
      if ( (1 << (i-1)) & availableDevices )  // if i is a remote devAddr
      {
        //lcdcmd(LINE1);
        msgbuf[1]=48+i;  // remote #
        msgbuf[6]=48+(extendedData[i][0] / 100);
        msgbuf[7]=48+((extendedData[i][0] / 10) % 10);
        msgbuf[8]=48+(extendedData[i][0] % 10);
        msgbuf[13]=48+(extendedData[i][1] / 100);
        msgbuf[14]=48+((extendedData[i][1] / 10) %10);
        msgbuf[15]=48+(extendedData[i][1] % 10);
        lputs(0, msgbuf);
        msDelay(2500);
      }
   }
}

unsigned long transaction_count;
static unsigned long transCountXaddr;			// physical memory address
/*******************************************************/
unsigned long transactionCount() { return transaction_count; }
/*******************************************************/
nodebug void incrementCounter()
{
   transaction_count++;
   setCountMessage();
   root2xmem( transCountXaddr, &transaction_count, 4);
   root2xmem( transCountXaddr+4, &statistics, sizeof(statistics));  // also save stats to xmem
   syncTransCount(); // send to the slave
}

/*******************************************************/
void loadTransactionCount()
{
	#GLOBAL_INIT
   {	transCountXaddr = 0; }

   // allocate xmem if not already done
   if (transCountXaddr == 0) transCountXaddr = xalloc(32);

   // Read transaction counter
   xmem2root( &transaction_count, transCountXaddr, 4);
   xmem2root( &statistics, transCountXaddr+4, sizeof(statistics));  // also read stats

   if (transaction_count < 0 || transaction_count > 10000000)
   { resetTransactionCount(0); }

   setCountMessage();
   syncTransCount(); // send to the slave
}
/******************************************************************/
void resetTransactionCount(unsigned long value)
{  transaction_count=value;
   setCountMessage();
   root2xmem( transCountXaddr, &transaction_count, 4);
   syncTransCount(); // send to the slave
}
void resetStatistics(void)
{
	statistics.trans_in=0;
	statistics.trans_out=0;
	statistics.deliv_alarm=0;
	statistics.divert_alarm=0;
	statistics.cic_lift_alarm=0;
   root2xmem( transCountXaddr+4, &statistics, sizeof(statistics));
}
/******************************************************************/
// MAKING DESIGN ASSUMPTION --> MNU_xxx value is the same as the index in menu[]
// define menu item numbers
enum MenuItems {
	   MNU_MARRIVAL_BEEP,
	   MNU_RARRIVAL_BEEP,
	   MNU_ALARM_SOUND,
	   MNU_PURGE,
	   MNU_ALARM_RESET,
      MNU_SETACTIVEMAIN,
	   MNU_SET_CLOCK,
	   MNU_COMM_STAT,
	   MNU_MSTACKING,
	   MNU_RSTACKING,
	   MNU_RESET_COUNT,
	   MNU_SET_STANAMES,
      MNU_SET_PHONENUMS,
	   MNU_DIVERTER_CFG,
	   MNU_SETPASSWORD,
      MNU_CLEARPASSWORDS,
	   MNU_SETTIMEOUT,
	   MNU_HEADDIVERTER,
	   MNU_AUTO_PURGE,
	   MNU_AUTOPUR_TIMER,
      MNU_SETASSLAVE,
	   MNU_DEF_STATIONS,
      MNU_ADVANCED_SETUP,
      MNU_RESET,
      MNU_ADMIN_FEATURES,
      MNU_MAINT_FEATURES,
      MNU_SYSTEM_CONFIG,
      MNU_VIEW_LOGS,
      MNU_VIEW_TLOG, // Transaction log
      MNU_VIEW_SLOG, // Summary log
      MNU_VIEW_ELOG, // Event log
      MNU_AUTO_RETURN,
      MNU_DNLD_TLOG,
	   MNU_LAST
};

// Define bitmasks for activation of menu items
#define MNU_ADV  0x0E
#define MNU_STD  0x01
#define MNU_ALRM 0x10
#define MNU_NONE 0x00
// Define parameter types
#define MNU_FLAG 01
#define MNU_VAL  02
#define MNU_TIME 03
#define MNU_CLK  04
#define MNU_OTHR 05
// define parameter menu
char NOch;       // dummy/temporary character place holder
const struct{
   char item;   // menu item
   char usage;  // when available to the user
   char *msg1;  // pointer to message
   char partype;  // parameter type (flag, clock, integer value, other)
   char *parval;  // parameter value
   char min;       // parameter minimum
   char max;       // parameter maximum
   char units[4];  // parameter units display
   } menu[] = {
 MNU_MARRIVAL_BEEP,  MNU_STD,  "BEEP ON MAIN ARRIVE", MNU_FLAG, &param.main_arrive_alert, 0, 0, "",
 MNU_RARRIVAL_BEEP,  MNU_ADV,  "BEEP ON REMT ARRIVE", MNU_FLAG, &param.remote_arrive_alert, 0, 1, "",
 MNU_ALARM_SOUND,    MNU_ALRM, "SILENCE ALARM",      MNU_FLAG, &alarm_sound_flag, 0, 0, "",
 MNU_PURGE,  MNU_STD|MNU_ALRM, "MANUAL PURGE",       MNU_OTHR, &NOch, 0, 0, "",
 MNU_ALARM_RESET,    MNU_ALRM, "RESET ALARM",        MNU_OTHR, &NOch, 0, 0, "",
 MNU_SETACTIVEMAIN,  MNU_STD,  "SET ACTIVE MAIN",    MNU_OTHR, &activeMainHere, 0, 0, "",
 MNU_SET_CLOCK, 		MNU_STD,  "SET CLOCK",          MNU_CLK,  &NOch, 0, 0, "",
 MNU_COMM_STAT,      MNU_ADV,  "SHOW COMMUNICATIONS",MNU_OTHR, &NOch, 0, 0, "",
 MNU_MSTACKING,      MNU_ADV,  "STACK AT MAIN",      MNU_FLAG, &param.stacking_ok[0], 0, 1, "",
 MNU_RSTACKING,      MNU_ADV,  "STACK AT REMOTES",   MNU_FLAG, &param.stacking_ok[1], 0, 1, "",
 MNU_RESET_COUNT,    MNU_ADV,  "SET TRANS COUNT",    MNU_OTHR, &NOch, 0, 0, "",
 MNU_SET_STANAMES,   MNU_ADV,  "SET STATION NAMES",  MNU_OTHR, &NOch, 0, 0, "",
 MNU_SET_PHONENUMS,  MNU_ADV,  "SET PHONE NUMBERS",  MNU_OTHR, &NOch, 0, 0, "",
 MNU_DIVERTER_CFG,   MNU_ADV,  "USE LOCAL DIVERTER", MNU_FLAG, &param.localDiverter, 0, 1, "",
 MNU_SETPASSWORD,    MNU_ADV,  "SET PASSWORD",       MNU_OTHR, &NOch, 0, 0, "",
 MNU_CLEARPASSWORDS, MNU_ADV,  "CLEAR PASSWORDS",    MNU_OTHR, &NOch, 0, 0, "",
 MNU_SETTIMEOUT,     MNU_ADV,  "DELIVERY TIMEOUT",   MNU_VAL,  (char *)&param.deliveryTimeout, 10, 240, "SEC",
 MNU_HEADDIVERTER,   MNU_ADV,  "USE HEAD DIVERTER",  MNU_FLAG, &param.headDiverter, 0, 1, "",
 MNU_AUTO_PURGE,     MNU_ADV,  "AUTOMATIC PURGE",    MNU_OTHR, &NOch, 0, 0, "",
 MNU_AUTOPUR_TIMER,  MNU_ADV,  "AUTO PURGE TIMER",   MNU_VAL,  (char *)&param.autoPurgeTimer, 10, 200, "SEC",
 MNU_SETASSLAVE,     MNU_ADV,  "SET AS SLAVE DEVICE",MNU_FLAG, &param.slaveController, 0, 1, "",
 MNU_DEF_STATIONS,   MNU_ADV,  "SET ACTIVE STATIONS",MNU_OTHR, &NOch, 0, 0, "",
 MNU_ADVANCED_SETUP, MNU_STD,  "Only in old menu",   MNU_FLAG, &diagnostic_mode, 0, 0, "",
 MNU_RESET,          MNU_NONE, "RESTART SYSTEM",     MNU_OTHR, &NOch, 0, 0, "",
 MNU_ADMIN_FEATURES, MNU_NONE, "ADMIN FEATURES",     MNU_OTHR, &NOch, 0, 0, "",
 MNU_MAINT_FEATURES, MNU_NONE, "MAINT FEATURES",     MNU_OTHR, &NOch, 0, 0, "",
 MNU_SYSTEM_CONFIG,  MNU_NONE, "SYSTEM CONFIG",      MNU_OTHR, &NOch, 0, 0, "",
 MNU_VIEW_LOGS,      MNU_NONE, "VIEW LOGS",          MNU_OTHR, &NOch, 0, 0, "",
 MNU_VIEW_TLOG,      MNU_NONE, "VIEW TRANSACTIONS",  MNU_OTHR, &NOch, 0, 0, "",
 MNU_VIEW_SLOG,      MNU_NONE, "VIEW SUMMARY LOG",   MNU_OTHR, &NOch, 0, 0, "",
 MNU_VIEW_ELOG,      MNU_NONE, "VIEW EVENT LOG",     MNU_OTHR, &NOch, 0, 0, "",
 MNU_AUTO_RETURN,    MNU_NONE, "AUTO RETURN TIMER",  MNU_VAL,  (char *)&param.autoReturnTimer, 0, 60, "MIN",
 MNU_DNLD_TLOG,      MNU_NONE, "DOWNLOAD TRANS LOG", MNU_OTHR, &NOch, 0, 0, "",
 MNU_LAST,           MNU_NONE, "END",                MNU_NONE, &NOch, 0, 0, "" };

char menuOrder[25];
void setupMenuOrder(char menuLevel)
{
	char i;
   i=0;
	// content of menu depends on if passwords are enabled or not
   switch (menuLevel)
   {
   case 0: // ALARM
      menuOrder[i++]=MNU_ALARM_SOUND;
      menuOrder[i++]=MNU_PURGE;
      menuOrder[i++]=MNU_ALARM_RESET;
   	break;
   case 1: // Basic User
      if (slaveAvailable) menuOrder[i++]=MNU_SETACTIVEMAIN;
      menuOrder[i++]=MNU_AUTO_PURGE;
      menuOrder[i++]=MNU_PURGE;
      menuOrder[i++]=MNU_VIEW_LOGS;
		menuOrder[i++]=MNU_ADMIN_FEATURES;
      menuOrder[i++]=MNU_MAINT_FEATURES;
      menuOrder[i++]=MNU_SYSTEM_CONFIG;
   	break;
   case 2: // Administrator
      menuOrder[i++]=MNU_MARRIVAL_BEEP;
      menuOrder[i++]=MNU_RARRIVAL_BEEP;
      menuOrder[i++]=MNU_MSTACKING;
      menuOrder[i++]=MNU_RSTACKING;
      menuOrder[i++]=MNU_AUTOPUR_TIMER;
      menuOrder[i++]=MNU_AUTO_RETURN;
      menuOrder[i++]=MNU_DNLD_TLOG;
      menuOrder[i++]=MNU_SET_CLOCK;
      menuOrder[i++]=MNU_RESET_COUNT;
      menuOrder[i++]=MNU_SET_STANAMES;
      menuOrder[i++]=MNU_SET_PHONENUMS;
      menuOrder[i++]=MNU_SETPASSWORD;
   	break;
   case 3: // Maintenance
      menuOrder[i++]=MNU_SETTIMEOUT;
      menuOrder[i++]=MNU_AUTO_PURGE;
      menuOrder[i++]=MNU_PURGE;
      menuOrder[i++]=MNU_SETPASSWORD;
      //menuOrder[i++]=MNU_DIV_TIMEOUT;
      //menuOrder[i++]=MNU_LIFT_TIMEOUT;
   	break;
   case 4: // System configuration (Colombo only)
      menuOrder[i++]=MNU_DIVERTER_CFG;
      menuOrder[i++]=MNU_HEADDIVERTER;
      //menuOrder[i++]=MNU_REMOTEDIVERTER;
      menuOrder[i++]=MNU_DEF_STATIONS;
      menuOrder[i++]=MNU_SETASSLAVE;
      menuOrder[i++]=MNU_COMM_STAT;
      menuOrder[i++]=MNU_CLEARPASSWORDS;
      menuOrder[i++]=MNU_RESET;
   	break;
   case 5: // view logs
      menuOrder[i++]=MNU_VIEW_SLOG; // transaction summary
      menuOrder[i++]=MNU_VIEW_TLOG; // transaction log
      menuOrder[i++]=MNU_VIEW_ELOG; // event log
   	break;
	}
   menuOrder[i]=MNU_LAST;

}
#define PAGE_SIZE 5
const char * const title[6] = { "-", "MENU", "ADMIN MENU", "MAINTENANCE MENU", "CONFIGURATION MENU", "LOGS MENU" };
char lcd_ShowMenu(char menuLevel, char page)
{  // returns if a next page is available
	char i, j;
   char rtnval;
   int row, count, button;
   char ttl;
   rtnval=TRUE;

   setupMenuOrder(menuLevel);
   ttl = (menuLevel<6) ? menuLevel : 0;  // which title to show
	lcd_drawScreen(2,title[ttl]);         // show the screen & title

   // make sure we can handle the page size
   if (page >= 1)
   { 	i = page * PAGE_SIZE;
   	// count backwards and reduce i if needed
   	for (j=i; j>0; j--) if (menuOrder[j]==MNU_LAST) i=j-1;
	} else i=0;

   count=0;
   lcd_Font("16B");
   while ((menuOrder[i] != MNU_LAST) && (count < PAGE_SIZE))
   {  row = 47 + count*30;
   	// put up text
	   //lcd_DispText(sys_message[menu[menuOrder[i]].msg1].msg, row, 50, MODE_TRANS);
      // put up button
	   lcd_ButtonDef( BTN_MNU_FIRST+menuOrder[i],  // menu items at 21+
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 40, row,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
         BTN_MARGINS, 5, 315,
	      BTN_TEXT, menu[menuOrder[i]].msg1,
	      BTN_TXTOFFSET, 10, 6,
	      BTN_BMP, BMP_long_button, BMP_long_button_dn,
	      BTN_END );
      i++;
      count++;
   }
   // show page # at the bottom
	j=0; while (menuOrder[j] != MNU_LAST) j++;
   count = ((j-1) / PAGE_SIZE) + 1;
	lcd_showPage(page+1, count);

   // is there another page to show?
   //if ( (menuOrder[i] == MNU_LAST) || (menuOrder[i+1] == MNU_LAST) ) rtnval=FALSE;
   if ( (menuOrder[i] == MNU_LAST) ) rtnval=FALSE;
   return rtnval;

}
char lcd_ProcessMenuItem(char menu_idx, char *menu_level)
{  // can modify menu_level using advanced configuration menu item
   // returns true if a flash parameter changed
   unsigned long clock_in_seconds;
   char work;
   char maxDigits;
   unsigned long temp_ulong;
   static char parChanged;
   parChanged=FALSE;  // assume not

   switch (menu[menu_idx].partype)
   {
   case MNU_VAL:
   	//lcd_drawScreen(4);sys_message[menu[menuOrder[i]].msg1].msg
      maxDigits = (menu[menu_idx].max > 999) ? 6 : 3;  // either 3 or 6 digits max
      temp_ulong = *menu[menu_idx].parval;
      if (lcd_GetNumberEntry(menu[menu_idx].msg1, &temp_ulong,
             menu[menu_idx].min, menu[menu_idx].max, menu[menu_idx].units, maxDigits))
      {
         *menu[menu_idx].parval = (char)temp_ulong;
         parChanged=TRUE;
      }
		break;
   case MNU_FLAG:
		parChanged=lcd_SelectChoice(menu[menu_idx].parval, menu[menu_idx].msg1, "YES", "NO");
      if (menu[menu_idx].max == 0) parChanged=0; // Parameter to be saved ??2
      break;
   case MNU_TIME:
      //ptr_ulong = (unsigned long *)menu[menu_idx].parval;
      //par_changed |= functionSetTime(menu[menu_idx].item, menu_idx, ptr_ulong);
      break;
   case MNU_CLK:
		lcd_setClock();      //clock_in_seconds = SEC_TIMER;
      syncDateAndTime(); // send to slave
      break;
   case MNU_OTHR:
      switch (menu[menu_idx].item)
      {
      case MNU_ADMIN_FEATURES:
      	// get pin for next menu level
         if (lcd_enableAdvancedFeatures(2, menu[menu_idx].msg1)) *menu_level=2;
         break;
      case MNU_MAINT_FEATURES:
      	// get pin for next menu level
         if (lcd_enableAdvancedFeatures(3, menu[menu_idx].msg1)) *menu_level=3;
         break;
      case MNU_SYSTEM_CONFIG:
      	// get pin for next menu level
         if (lcd_enableAdvancedFeatures(4, menu[menu_idx].msg1)) *menu_level=4;
         break;
      case MNU_VIEW_LOGS:
         *menu_level=5;  // Logs menu items
         break;
      case MNU_ALARM_RESET:           // alarm reset
      	work=FALSE;
			lcd_SelectChoice(&work, menu[menu_idx].msg1, "YES", "NO");
         if (work) system_state=CANCEL_STATE;
         *menu_level=99; // exit menu
         break;
      case MNU_SETACTIVEMAIN:
			lcd_SelectChoice(menu[menu_idx].parval, menu[menu_idx].msg1,
         	param.station_name[0].name, param.station_name[SLAVE].name);
         setActiveMain(*menu[menu_idx].parval);
      	break;
      case MNU_PURGE:                // purge system
         purgeSystem(0);             // 0 = manual; 1 = auto
         break;
      case MNU_AUTO_PURGE:           // purge system
         purgeSystem(1);             // 0 = manual; 1 = auto
         break;
      case MNU_RESET_COUNT:
      	maxDigits=6;
         temp_ulong = transactionCount();
	      if (lcd_GetNumberEntry(menu[menu_idx].msg1, &temp_ulong,
         		 0, 999999, menu[menu_idx].units, maxDigits))
            resetTransactionCount(temp_ulong);
         break;
      case MNU_SET_STANAMES:        // set station names
	      parChanged=lcd_editStationNames();
         if (parChanged) setActiveMainMsg();  // reset rcv @ message if needed
         break;
      case MNU_SET_PHONENUMS:       // set phone numbers
      	parChanged=lcd_editPhoneNums();
      	break;
      case MNU_DEF_STATIONS:        // define active stations
         parChanged=lcd_defineActiveStations();
         break;
      case MNU_SETPASSWORD:        // set new password
         // get the PIN for the given menu level
         if (*menu_level==2) parChanged |= lcd_getPin(param.adminPassword, "SET ADMIN PASSWORD");
         else if (*menu_level==3) parChanged |= lcd_getPin(param.maintPassword, "SET MAINT PASSWORD");
         break;
      case MNU_CLEARPASSWORDS:    // reset passwords
      	param.adminPassword[0]=0;
         param.maintPassword[0]=0;
         parChanged=TRUE;
         break;
      case MNU_COMM_STAT:
         show_comm_test(1); // wait for button press
         break;
      case MNU_VIEW_SLOG:
	      lcd_showTransSummary();
         break;
      case MNU_VIEW_TLOG:
         lcd_showTransactions();
      	break;
      case MNU_DNLD_TLOG:
      	downloadTransLog();
         break;
      case MNU_RESET:
         // go into long loop to allow watchdog reset
         clock_in_seconds = SEC_TIMER;
         lcd_drawScreen(3, menu[menu_idx].msg1);
	      lcd_Font("24");
	      lcd_DispText("WAITING FOR RESET", 10, 85, MODE_NORMAL);
         #asm
            ipset 3          ; disable interrupts so that the periodic ISR doesn't hit the watchdog.
            ld a,0x53        ; set the WD timeout period to 250 ms
            ioi ld (WDTCR),a
         #endasm
         while (SEC_TIMER - clock_in_seconds < 5);
	      lcd_DispText("UNABLE TO RESET", 10, 115, MODE_NORMAL);
         msDelay(1000);
         break;
      }
	}
   return parChanged;
}
/******************************************************************/

void setActiveMain(char setToMaster)
{
	if (setToMaster) param.activeMain = MASTER;
   else             param.activeMain = SLAVE;

   if (param.slaveController)
   {  // set flag to send new status
      if (param.activeMain==MASTER) slaveReturnStatus |= 0x04;
      else slaveReturnStatus |= 0x02;
   }
   setActiveMainMsg();

}
void setActiveMainMsg()
{  // setup active main message shown on lcd
	char i;
	char mybuf[20];
	char start;

   //strcpy(sys_message[MSG_SDEFAULT2].msg, "  RCV @ ");
   strcpy(mybuf, "RCV @ ");
   if (param.activeMain == MASTER) strncat(mybuf, param.station_name[0].name,10);
   else                            strncat(mybuf, param.station_name[8].name,10);

   // center message
   start = (MSG_LEN - strlen(mybuf)) / 2;
   // place in destination
   // leading spaces
   for (i=0; i<start; i++)
   	sys_message[MSG_SDEFAULT2].msg[i]=32;
   // message
   for (i=0; i<strlen(mybuf); i++)
   	sys_message[MSG_SDEFAULT2].msg[i+start]=mybuf[i];
   // trailing spaces
    for (i=start+strlen(mybuf); i<MSG_LEN; i++)
      sys_message[MSG_SDEFAULT2].msg[i]=32;
    // end of string
    sys_message[MSG_SDEFAULT2].msg[MSG_LEN]=0;

}
/******************************************************************/
void displayFunctionMessage(char mnu_idx, char msg_item, char msg_value)
{  // mnu_idx is the index to menu[]
   // msgs correspond to display lines 3, 4
   // if msg_item is zero, use .msg1, .msg2

   unsigned long *ptr_ulong;
   unsigned long val_ulong;

   // display the menu message corresponding to the menu item
   // update some dynamic messages first
   switch (menu[mnu_idx].partype)
   {
   case MNU_FLAG:    // update flag message
      setFlagMessage(*menu[mnu_idx].parval);
      break;
   case MNU_CLK:    // update clock message
      setTimeMessages(MSG_DATE_TIME, SEC_TIMER);
      break;
   case MNU_TIME:   // update timer message
      ptr_ulong = (unsigned long *)menu[mnu_idx].parval;
      //setTimeMessages(menu[mnu_idx].msg3, *ptr_ulong);
      break;
   case MNU_VAL:   // update parameter value message
      val_ulong = (unsigned long)*menu[mnu_idx].parval;
      setParValueMessage(MSG_PAR_VALUE, *menu[mnu_idx].parval, menu[mnu_idx].units);
      break;
   }

   // display the messages
//   message_add(TRANSLCD, MSG_FUNCTION, menu[mnu_idx].msg1, ONESHOTA);
//   if (msg_item==0)
//      message_add(SYSTEMLCD, menu[mnu_idx].msg2, menu[mnu_idx].msg3, ONESHOT);
//   else
//      message_add(SYSTEMLCD, msg_item, msg_value, ONESHOT);

}

// set clock functions
char functionSetTime(char what_timer, char index, unsigned long *time_val)
{  // what_timer is the base menu item

}
char functionSetParValue(char menu_item, unsigned long * par_value,
                         unsigned long par_min, unsigned long par_max,
                         char * par_units)
{  // allow changing an unsigned long parameter value

}
/******************************************************************/
// define purge system states
#define  PURGE_ARE_YOU_SURE      0x20
#define  PURGE_GET_DIRECTION     0x21
#define  PURGE_GET_STATION       0x22
#define  PURGE_SET_DIVERTER      0x23
#define  PURGE_WAIT_DIVERTER     0x24
#define  PURGE_RUN               0x25
#define  PURGE_GET_HEADDIVERTER  0X26
#define  PURGE_RUN_DONE          0x27
#define  PURGE_RUN_AUTO          0x28
#define  PURGE_EXIT              0x29

void purgeSystem(char auto_purge)
{
   // Input parameter 'how' is manual (0) or automatic (1)

   struct iomessage command, response;
   char purge_state, new_state, k, station_msg;
   char mymessage[17];
   char i;  // loop counter
   char remote_data_p[4];
   char first_time_here;
   char align_headdiverter;
   char blower_purge_state;   // used to tell headdiverter blower what to do
   char first_purge_state;    // initial state of the purge mode
   char auto_station;
   char auto_blower;
   char title[12];
   int button; // from color lcd
   int col;
   unsigned long ms_autoPurgeTimer;
   ms_autoPurgeTimer = param.autoPurgeTimer * 1000ul;  // convert seconds to milliseconds
	echoLcdToTouchscreen=FALSE;  // Touchscreen has own messages, don't echo from lcd

   eventlog.start_tm=SEC_TIMER;

   // if auto purge, build up for control loop
   auto_station = 1;  // set first auto purge station
   state_timer=MS_TIMER;
   if (auto_purge)
   {  //
	   eventlog.status=ESTS_AUTOPURGE;
      //first_purge_state=PURGE_SET_DIVERTER;
      first_purge_state=PURGE_ARE_YOU_SURE;
      // operation depends on headdiverter config
       if (param.headDiverter==TRUE)
       {
           auto_blower=blwrPRS;  // always use pressure
           align_headdiverter=1;  // align main
           systemStation=0;    // no remote station
           systemStationb=0;
           system_direction=DIR_SEND;
       }
       else
       {
           auto_blower=blwrVAC;  // always use vacuum
           align_headdiverter=0;   // no headdiverter
           systemStationb=firstBit(STATION_SET);
           systemStation=bit2station(systemStationb);
           system_direction=DIR_RETURN;
       }
       strcpy(title, "AUTO PURGE");
   }
   else
   {
	   eventlog.status=ESTS_MANPURGE;
	   // set entry state based on if headdiverter is used
	   if (param.headDiverter==TRUE) first_purge_state=PURGE_GET_HEADDIVERTER;
	   else first_purge_state=PURGE_GET_STATION;
	   system_direction = DIR_SEND;       // undefined
	   align_headdiverter = 2;              // undefined (align remote)
	   strcpy(title, "PURGE");
   }
   purge_state = first_purge_state;
   new_state = purge_state;
   blower_purge_state = IDLE_STATE;   // remote blower idle
   first_time_here = TRUE;            // use to show state message once per state change
   station_msg = 1;                   // anything

   inUse(FLASH, STATION_SET);

   // display initial messages
   //if (auto_purge) message_add(TRANSLCD, MSG_FUNCTION, MSG_AUTO_PURGE, ONESHOTA);
   //else            message_add(TRANSLCD, MSG_FUNCTION, MSG_PURGE, ONESHOTA);
   //message_add(SYSTEMLCD, MSG_BLANK, MSG_BLANK, ONESHOT);
   // Setup color lcd display and buttons
	lcd_drawScreen(5, title);
	lcd_Font("24");

   while ((purge_state != PURGE_EXIT) && !secTimeout(menu_timeout) )
   {
      hitwd();                // hit the watchdog timer
      showactivity();
      check_diverter();
      processBlower();
      button = lcd_GetTouch(10);

      // Exit anytime FUNC is triggered
      // except in PURGE_RUN then go back to first_purge_state (through PURGE_RUN_DONE)
      // if (functionButton(FUNC_BUTT, FUNC_TRIG))
      if (button == BTN_EXIT)
      {   //if (headDiverter==TRUE && purge_state==PURGE_GET_DIRECTION)
          if (purge_state==PURGE_RUN)
               new_state=PURGE_RUN_DONE;
          else new_state=PURGE_EXIT;
      }
      // Exit anytime anything is pressed in auto purge
      if (auto_purge)  // check for cancel of auto purge
      {
         if ( di_requestToSend || (button == BTN_CANCEL) )
         {  new_state=PURGE_EXIT;
            purge_state=PURGE_EXIT; // Force in right away
         }
      }

      // enter local loop to process purge
      switch (purge_state) {
      case PURGE_ARE_YOU_SURE:
         if (first_time_here==TRUE)
         {  // show Start button
	         lcd_Font("16B");
	         lcd_ButtonDef( 1,
	            BTN_MOM,                      // momentary operation
	            BTN_TLXY, 5, 205,             // starting x,y for buttons
	            BTN_TYPE, BUTTON_RELEASE,
	            BTN_MARGINS, 5, 330,         // set left and right margins
	            BTN_SEP, 63, 43,              // set up for button sep
	            BTN_TEXT, "Start",
	            BTN_TXTOFFSET, 9, 9,
	            BTN_BMP, BMP_med_button, BMP_med_button_dn,
	            BTN_END );

            // show message prompt
            lcd_DispText("PRESS START BUTTON TO BEGIN", 50, 50, MODE_NORMAL);
				lcd_Font("24");
         }

         if (button==1) new_state=PURGE_SET_DIVERTER;

      	break;

      case PURGE_GET_HEADDIVERTER:            // get headdiverter alignment
         if (first_time_here==TRUE)
         {
            strcpy(mymessage, "(+)  TO         ");
            for (k=0; k<strlen(param.station_name[0].name); k++)
            { mymessage[k+8]=param.station_name[0].name[k]; }
            //lcd_print(SYSTEMLCD, 0, mymessage);
            //lcd_print(SYSTEMLCD, 1, "(-)  TO REMOTE  ");
			   lcd_drawScreen(5, title);
	         lcd_DispText("SETUP DIVERTER", 50, 50, MODE_NORMAL);
	         lcd_DispText(ltrim(sys_message[MSG_TO].msg), 140, 90, MODE_NORMAL);
	         lcd_ButtonDef( 1,
	            BTN_MOM,                      // momentary operation
	            BTN_TLXY, 100, 85,               // starting x,y for buttons
	            BTN_TYPE, BUTTON_RELEASE,
	            BTN_MARGINS, 5, 315,        // set left and right margins
	            BTN_SEP, 35, 35,              // set up for button sep
	            BTN_TEXT, "",
	            BTN_BMP, BMP_button_up, BMP_button_dn,
	            BTN_END );
	         lcd_DispText("TO SUB STATION", 140, 125, MODE_NORMAL);
	         lcd_ButtonDef( 2,
	            BTN_TLXY, 100, 120,               // starting x,y for buttons
	            BTN_BMP, BMP_button_up, BMP_button_dn,
	            BTN_END );
            if ((slaveAvailable) || (param.slaveController))
            {
               lcd_DispText(ltrim(sys_message[MSG_TO+SLAVE].msg), 140, 160, MODE_NORMAL);
	            lcd_ButtonDef( 3,
	               BTN_TLXY, 100, 155,               // starting x,y for buttons
	               BTN_BMP, BMP_button_up, BMP_button_dn,
	               BTN_END );
            }
         }

         // TO MAIN
         if (button == 1)
         {   new_state=PURGE_SET_DIVERTER;
             align_headdiverter=1;  // align main
             systemStation=0;    // no remote station
             systemStationb=0;
         }
         // TO REMOTE
         if (button == 2)
         {   new_state=PURGE_GET_STATION;
             align_headdiverter=2;  // align remote
         }
         // TO SLAVE
         if (button == 3)
         {   new_state=PURGE_SET_DIVERTER;
             align_headdiverter=3;  // align slave
             systemStation=0;    // no remote station
             systemStationb=0;
         }

         break;

      case PURGE_GET_STATION:            // get station selection

         if (first_time_here==TRUE)
         {
            //lcd_print(SYSTEMLCD, 0, sys_message[MSG_SEL_STATION].msg);
            //lcd_print(SYSTEMLCD, 1, "    TO PURGE    ");
			   lcd_drawScreen(5, title);
	         lcd_DispText("SELECT STATION TO PURGE", 20, 50, MODE_NORMAL);
            // draw station buttons
            col=40;
            for (i=0; i<LAST_STATION; i++)
            {  if ((1<<i) & STATION_SET)
            	{  mymessage[0]=49+i; mymessage[1]=0;
	               lcd_ButtonDef( i,    // station# - 1
	                  BTN_MOM,                      // momentary operation
	                  BTN_TLXY, col, 90,               // starting x,y for buttons
	                  BTN_TYPE, BUTTON_RELEASE,
	                  BTN_TEXT, mymessage,
	                  BTN_BMP, BMP_button_up, BMP_button_dn,
	                  BTN_END );
                  col+=40;
               }
            }
         }

         if (di_requestToSend & STATION_SET)
         {  systemStation=firstBit(di_requestToSend & STATION_SET);
            systemStationb=station2bit(systemStation);
            new_state=PURGE_SET_DIVERTER;
         }
         if ((button >= 0) && (button < LAST_STATION))
         {  systemStation = firstBit((1<<button) & STATION_SET);
            systemStationb=station2bit(systemStation);
            new_state=PURGE_SET_DIVERTER;
         }

         break;

      case PURGE_SET_DIVERTER:  // set diverter and continue

         if (first_time_here==TRUE)
         {
            //message_add(TRANSLCD, MSG_FUNCTION, MSG_PURGE, ONESHOTA);
            //message_add(SYSTEMLCD, MSG_SETTING, MSG_TO+systemStation, ONESHOT);
            //lcd_print(SYSTEMLCD, 0, sys_message[MSG_SETTING].msg);
            //lcd_print(SYSTEMLCD, 1, sys_message[MSG_TO+systemStation].msg);
			   lcd_drawScreen(5, title);
	         lcd_DispText(ltrim(sys_message[MSG_SETTING].msg), 50, 50, MODE_NORMAL);
            if (align_headdiverter==1)  // align main
		         lcd_DispText(ltrim(sys_message[MSG_TO].msg), 50, 80, MODE_NORMAL);
            else if (align_headdiverter==3) // align slave
		         lcd_DispText(ltrim(sys_message[MSG_TO+SLAVE].msg), 50, 80, MODE_NORMAL);
            else
		         lcd_DispText(ltrim(sys_message[MSG_TO+systemStation].msg), 50, 80, MODE_NORMAL);
            state_timer=MS_TIMER;
         }

         // Stay in this state until diverter command received
         set_diverter(systemStation);
         command.devAddr=ALL_DEVICES;
         command.command=SET_DIVERTER;
         command.station=systemStation;
         command.data[0]=align_headdiverter;
         command.data[1]=0; // mainStation
         if (send_command(command)) new_state=PURGE_WAIT_DIVERTER;
         break;

      case PURGE_WAIT_DIVERTER:

         // no additional messages to show here
         if (MS_TIMER-state_timer >= DIVERTER_TIMEOUT)
         {  // timeout
             //lcd_print(SYSTEMLCD, 1, sys_message[MSG_TIMEOUT].msg);
             lcd_DispText(sys_message[MSG_TIMEOUT].msg, 50, 180, MODE_NORMAL);
             new_state=PURGE_EXIT;
         }

         // Stay in this state until diverter in position
         msDelay(10);
         if (divertersReady(systemStation, align_headdiverter, 0))
         {
             station_msg = MSG_TO + systemStation;
             if (auto_purge) new_state=PURGE_RUN_AUTO;
             else new_state=PURGE_RUN;
         }
         break;

      case PURGE_RUN:

         if (first_time_here==TRUE)
         {
             //message_add(TRANSLCD, MSG_FUNCTION, MSG_PURGE, ONESHOTA);
             //message_add(SYSTEMLCD, station_msg, MSG_BLANK, ONESHOT);
            // lcd_print(SYSTEMLCD, 0, " F1=PRS  F2=VAC ");
            //lcd_print(SYSTEMLCD, 0, "(+)=PRS (-)=VAC ");
            //lcd_print(SYSTEMLCD, 1, sys_message[MSG_BLANK].msg);
			   lcd_drawScreen(5, title);
	         lcd_DispText("OPERATE BLOWER", 62, 50, MODE_NORMAL);
            if (align_headdiverter==1)  // align main
		         lcd_DispText(ltrim(sys_message[MSG_TO].msg), 62, 75, MODE_NORMAL);
            else if (align_headdiverter==3) // align slave
		         lcd_DispText(ltrim(sys_message[MSG_TO+SLAVE].msg), 62, 75, MODE_NORMAL);
            else
		         lcd_DispText(ltrim(sys_message[MSG_TO+systemStation].msg), 62, 75, MODE_NORMAL);
	         lcd_DispText("PRESSURE", 140, 110, MODE_NORMAL);
	         lcd_ButtonDef( 3,
	            BTN_LAT,                      // momentary operation
	            BTN_TLXY, 100, 103,               // starting x,y for buttons
	            BTN_TYPE, BUTTON_LAT_0,
	            BTN_MARGINS, 5, 315,        // set left and right margins
	            BTN_SEP, 35, 35,              // set up for button sep
	            BTN_TEXT, "","",
	            BTN_BMP, BMP_button_off, BMP_button_on,
	            BTN_END );
	         lcd_DispText("VACUUM", 140, 147, MODE_NORMAL);
	         lcd_ButtonDef( 4,
	            BTN_TLXY, 100, 140,               // starting x,y for buttons
	            BTN_BMP, BMP_button_off, BMP_button_on,
	            BTN_END );
            //lcd_DispBitmap(BMP_LEDOFF,
         }
         // Pressure
         // if (functionButton(FUNC_F1, FUNC_CURR))
         if (button%256==3)
         {  if ((blower_purge_state != WAIT_FOR_REM_ARRIVE) || (button==259))
            {
                blower_purge_state = WAIT_FOR_REM_ARRIVE;  // always pressure
                blower(blwrPRS);
                //lcd_print(SYSTEMLCD, 1, "    PRESSURE    ");
                //lcd_DispText("PRESSURE", 120, 155, MODE_NORMAL);
                lcd_SetState( 4, 0 ); // make sure vacuum button is off
                system_direction=DIR_SEND;
            }
            // NEW to toggle on each key press
            else
            {
                blower_purge_state=IDLE_STATE;
                blower(blwrIDLE);
                //lcd_print(SYSTEMLCD, 1, sys_message[MSG_BLANK].msg);
                //lcd_DispText("                  ", 120, 155, MODE_NORMAL);
            }
            // menu_timeout = SEC_TIMER + 60;  // Don't timeout while purging
         }
         // Vacuum
         // else if (functionButton(FUNC_F2, FUNC_CURR))
         else if (button%256==4)
         {  if ((blower_purge_state != WAIT_FOR_REM_DEPART) || (button==260))
            {
                blower_purge_state = WAIT_FOR_REM_DEPART;  // always vacuum
                blower(blwrVAC);
                //lcd_print(SYSTEMLCD, 1, "     VACUUM     ");
                //lcd_DispText("VACUUM    ", 120, 155, MODE_NORMAL);
                lcd_SetState( 3, 0 ); // make sure pressure button is off
                system_direction=DIR_RETURN;
            }
            // NEW to toggle on each key press
            else
            {
                blower_purge_state=IDLE_STATE;
                blower(blwrIDLE);
                //lcd_print(SYSTEMLCD, 1, sys_message[MSG_BLANK].msg);
                //lcd_DispText("                  ", 120, 155, MODE_NORMAL);
            }
            // menu_timeout = SEC_TIMER + 60;  // Don't timeout while purging
         }
         // NEW never timeout when running purge
         menu_timeout = SEC_TIMER + 60;  // Don't timeout while purging
         // Idle
         //else
         //{  if (blower_purge_state != IDLE_STATE)
         //   {
         //       blower_purge_state=IDLE_STATE;
         //       blower(blwrIDLE);
         //       lcd_print(SYSTEMLCD, 1, sys_message[MSG_BLANK].msg);
         //   }
         //}

          // show message if arrival at headdiverter
         if ((remote_data_p[REMOTE_ARRIVE] & HEADDIVERTERSTATION)
            && (system_direction==DIR_RETURN))
         {
            //lcd_print(SYSTEMLCD, 1, "CARRIER @ BLOWER");
            lcd_DispText("CARRIER @ BLOWER", 120, 180, MODE_NORMAL);
         }

         break;

      case PURGE_RUN_AUTO:
         // wait for auto purge duration then go to the next station
         if (first_time_here==TRUE)
         {
            blower(auto_blower);
            if (auto_blower == blwrPRS) blower_purge_state = WAIT_FOR_REM_ARRIVE;
            else blower_purge_state = WAIT_FOR_REM_DEPART;
            //lcd_print(SYSTEMLCD, 0, "    PURGING     ");
            //lcd_print(SYSTEMLCD, 1, sys_message[station_msg].msg);
				lcd_clearMiddle();
	         lcd_DispText("PURGING ", 20, 50, MODE_NORMAL);
            //lcd_DispText(ltrim(sys_message[MSG_TO+systemStation].msg), 0, 0, MODE_NORMAL);
            if (align_headdiverter==3)  // align slave
		         lcd_DispText(ltrim(sys_message[MSG_TO+SLAVE].msg), 0, 0, MODE_NORMAL);
            else
		         lcd_DispText(ltrim(sys_message[MSG_TO+systemStation].msg), 0, 0, MODE_NORMAL);
         }

         menu_timeout = SEC_TIMER + 60;  // Don't timeout while purging

         if (MS_TIMER-state_timer > ms_autoPurgeTimer)
         {   // turn off blower
             blower(blwrIDLE);   // Always turn off the blower when leaving ... just in case.
             blower_purge_state=IDLE_STATE;

             // go to the next station
             if ((align_headdiverter==1) && slaveAvailable)
             {
                align_headdiverter=3;  // align slave
             } else
             {
	             systemStation++;
	             align_headdiverter=2;  // align remote
	             // make sure its an active station
	             while ( ((station2bit(systemStation) & STATION_SET)==0)
	                   && (systemStation < 8) ) systemStation++;
             }

            // set the next state
            if (systemStation >= 8) new_state=PURGE_EXIT;
            else
            {  new_state = PURGE_SET_DIVERTER;
               systemStationb = station2bit(systemStation);
            }
         }
         break;

      case PURGE_RUN_DONE:  // used to force one time through loop for remote command of blower
         blower_purge_state=IDLE_STATE;
         blower(blwrIDLE);
         // go to next state after one extra time through ... to set blowers properly
         if (first_time_here!=TRUE) new_state=first_purge_state;
         break;

      case PURGE_EXIT:
         // leaving purge here
         blower(blwrIDLE);   // Always turn off the blower when leaving ... just in case.
         blower_purge_state=IDLE_STATE;
         break;

      default:
         new_state=PURGE_EXIT;
         break;
      } // end switch

      // check for purge state change
      if (purge_state != new_state)
      {
         first_time_here=TRUE;    // wasn't here yet
         purge_state=new_state;   // this is where to be
         state_timer=MS_TIMER;
      }
      else first_time_here=FALSE; // were already here

	  // Check remote inputs only if processing PURGE_WAIT_DIVERTER or PURGE_RUN
      // or PURGE_RUN_DONE or PURGE_EXIT
	  if ( (purge_state==PURGE_WAIT_DIVERTER)
        || (purge_state==PURGE_RUN)
        || (purge_state==PURGE_RUN_AUTO)
        || (purge_state==PURGE_RUN_DONE)
        || (purge_state==PURGE_EXIT) )
	  {
        // Add check for remote inputs in V2.34 for Up-Receive control
        // and now for headdiverter too
        command.devAddr=ALL_DEVICES;
        command.command=RETURN_INPUTS;
        command.station=0;
        command.data[0]=0;
        command.data[1]=blower_purge_state;    // send blower state
        // command.data[2]=system_direction;      // send diverter direction
	     command.data[2]=outputvalue[devInUseSolid];     // was system_direction;
	     command.data[3]=outputvalue[devInUseFlash];
        command.data[4]=STATION_SET;

		 msDelay(10);
		 if (send_n_get(command, &response))
		 {
			if (response.command==INPUTS_ARE)
			{
			  // store remote response in local var
			  for (k=0; k<4; k++) remote_data_p[k]=response.data[k];
			  // force unused doors closed (on) and other unused inputs off
			  remote_data_p[REMOTE_DOOR] |= ~STATION_SET;
			  remote_data_p[REMOTE_CIC] &= STATION_SET;
			  remote_data_p[REMOTE_RTS] &= STATION_SET;
         } // end if
       } // end if
     } // end if
   } // end while
   inUse(OFF, STATION_SET);
	echoLcdToTouchscreen=TRUE;  // Reenable echo of lcd to Touchscreen
   eventlog.end_tm=SEC_TIMER;
   addTransaction( eventlog );  // transaction resumed, log the event

}

int readParameterSettings(void)
{  // Read the parameter block param
   int rtn_code;
   rtn_code = readUserBlock(&param, 0, sizeof(param));
   if (rtn_code || (param.sysid != 63))
   {  // fault or parameters not initialized
      // set default parameters
      param.sysid=63;
   	param.names_init=0;
		param.stacking_ok[0]=FALSE;
		param.stacking_ok[1]=FALSE;
   	param.remote_arrive_alert=TRUE;
		param.localDiverter=FALSE;      // local diverter configuration
   	param.activeStations=1;         // active station set
		param.autoPurgeTimer=10;        // auto purge timer in seconds
   	param.deliveryTimeout=60;       // delivery timeout in seconds
   	param.headDiverter=FALSE;
		param.pw_enabled=FALSE;
   	param.slaveController=MASTER;    // master (0) or slave (SLAVE)
   }
   param.activeMain = MASTER;  // always default to master
   return rtn_code;
}
int writeParameterSettings(void)
{  // Write the parameter block param
   int rtn_code;
   rtn_code = writeUserBlock(0, &param, sizeof(param));
   return rtn_code;
}
#ifdef USE_TCPIP
int sendEthernetCommand(char sample)
{
// static long sequence;
   char        counter;
   auto char   buf[128];
   auto int    length, retval;
   unsigned long timer_val;
   char * cptr;  // pointer to reference into timer value

   // communication buffer content
   // Command, Source, Destination, Sample, Timer

// #GLOBAL_INIT
// {
//    sequence = 0;
// }

   /* fill the packet with sample data */
   // sprintf(buf, "SEQ=%ld",sequence);
   // determine destination counter
   //if (param.counter2active == FALSE) counter = 1;
   //else if (param.counter1active == FALSE) counter = 2;
   //else counter = ((sample-1) % 2) + 1;
   counter = 1;
   buf[0] = 42; // sample decay time remaining
   buf[1] = 0;  // always coming from the master
   buf[2] = 0; //counter;
   buf[3] = 0; //sample;
//   timer_val = timerRemainingTime_MSEC(sample);  // send in MSec
//   cptr = (char *)&timer_val;
   buf[4] = 0; // *cptr++;
   buf[5] = 0; // *cptr++;
   buf[6] = 0; // *cptr++;
   buf[7] = 0; // *cptr++;
   buf[8] = 0;
   length = 8; // length = strlen(buf) + 1;

   /* send the packet */
   retval = udp_send(&sock, buf, length);
   if (retval < 0) {
      printf("Error sending datagram!  Closing and reopening socket...\n");
      sock_close(&sock);
      if(!udp_open(&sock, LOCAL_PORT, resolve(REMOTE_IP), REMOTE_PORT, NULL)) {
         printf("udp_open failed!\n");
      }
   }
}
#endif
void maintenance(void)
{  // handle all regularly scheduled calls

   hitwd();                // hit the watchdog timer
   showactivity();
   //rn_keyProcess(DevRN1600, 0);  // process keypad device

   // process command communications
#ifdef USE_TCPIP
   tcp_tick(NULL);
#endif

   // handle carrier in chamber light
   do_CICLight(di_carrierInChamber);

   // process flashing inUse lights
   if ((MS_TIMER %500) < 200) digBankOut(0, ~(outputvalue[devInUseFlash] | outputvalue[devInUseSolid]));
   else digBankOut(0, ~outputvalue[devInUseSolid]);

   // process blower
   processBlower();

   // process arrival alert
	processMainArrivalAlert();

}
void exercise_outputs()
{
   /* Exercise all lighted outputs */
   alarm(OFF);
   do_alert(ON);
   inUse(FLASH, ALL_STATIONS);
   hitwd();          // "hit" the watchdog timer
   msDelay(1000);
   do_alert(OFF);
   hitwd();          // "hit" the watchdog timer
   msDelay(1000);
   hitwd();
   inUse(ON, ALL_STATIONS); maintenance(); msDelay(200);
   inUse(OFF, ALL_STATIONS); maintenance(); msDelay(200);
   inUse(ON, ALL_STATIONS); maintenance();  msDelay(200);
   inUse(OFF, ALL_STATIONS); maintenance();
   hitwd();          // "hit" the watchdog timer

}

/******************************************************************/
char station2bit(char station)
{  /* Converts the station number assignment to an equivalent
      bit value.  ie. station 3 -> 0100 (=4) .. same as 2^(sta-1)
      NOTE: Returns 0 if station is not 1..8  */

   if (station) return 1 << (station-1);
   else return 0;
}
/******************************************************************/
char bit2station(char station_b)
{  /* Converts a bit assignment to the bit number value
      ie. 0100 -> station 3.
NOTE: Returns 0 if more than 1 station bit is active */

   char stanum, i;
   stanum = 0;

   for (i=0; i<8; i++)
   {
      if (1<<i == station_b) stanum=i+1;
   }
   return stanum;
}
/******************************************************************/
char firstBit(char bitdata)
{  // Return # of first bit that is on (1-8)
   char i;
   i=0;
   while (i<8 && ((1<<i & bitdata)==0)) i++;
   if (i<8) return i+1;
   else     return 0;
}

/******************************************************************/
// PASSWORD FUNCTIONS
/******************************************************************/
// uses
// param.pw_enabled;         // flag indicating if password is setup/enabled
// param.admPassword[5];     // buffer for system password

char verifyPassword()
{   // gets the password from the user and checks it against
    // the system password.
    // Returns 1 if the entered password matches or 0 if it doesn't.
}

char setPassword()
{   // prompts user to enter new password
    // returns TRUE if password was changed
}
void clearPassword()
{
}

char getPassword(char *pwbuff)
{   // reads the password from the station selection push buttons or keypad

}
// This function is replaced by readParameterSettings
// void loadPassword()
// This function is replaced by writeParameterSettings
// void savePassword()

/******************************************************************/
/* Communications drivers */
#define CMD_LENGTH  11
#define RCV_TIMEOUT 70
#define ACK_TIMEOUT 30
//#define BUF_COUNT 1
//#define BUF_SIZE 10
#define BAUD_RATE 19200
int badcmd;
#define CSTATS 10
unsigned long commstat[CSTATS];
char comError, wasComError;
const char * const commlbl[CSTATS] = {
"Messages Sent   ","Messages Recvd  ","Msgs Not Recvd  ","Msgs Answered   ",
"# BAD CHECKSUM  ","# INCOMPLETE INP","# NO STX/ETX    ","# UNKNOWN ACK   ",
"# NAK           ","# NIL           " };

// message buffer for general work use
struct iomessage workmsg;

void disable485whenDone(void)
{
   while (serDwrUsed());          // wait for all bytes to be transmitted
   while (RdPortI(SDSR) & 0x0C);  // wait for last byte to complete
   serDrdFlush();                 // flush the read buffer
   ser485Rx();                    // disable transmitter
}
char init_communication()
{
   char stat, i;

   // Initialize packet driver
   // Coyote uses port D for RS485
   // use default buffer sizes (31 bytes, tx & rx)
   serDopen(BAUD_RATE);
   ser485Rx();
   serDrdFlush();     // clear receive buffer
   serDwrFlush();     // clear transmit buffer

   badcmd=0;

   workmsg.devAddr=ALL_DEVICES;
   workmsg.command=RESET;
   workmsg.station=0;
   stat = send_command( workmsg );   // return code to determine comm status

   // clear comm status counters
   for (i=0; i<CSTATS; i++) commstat[i]=0;
   wasComError=0;   // reset com error state change flag

   return stat;
}
unsigned long t1, t2, t3, t4;    // debug
char send_n_get(struct iomessage message, struct iomessage *response)
{
   // Transmits message to 1 or all devices and combines responses for return
   // Verify success by response.devAddr -- equals those that answered BIT-WISE (message.devAddr=3 returns 0x04)
   // Uses global data structure extendedData[]
   char i, j, firstDevAddr, lastDevAddr;
   char good,retry,anygood;

   response->devAddr=0;
   response->command=0; // message.command;
   response->station=0;
   for (i=0; i<NUMDATA; i++) response->data[i]=0;

   // process send/return for each controller necessary
   if (message.devAddr == ALL_DEVICES)
   {
      firstDevAddr=FIRST_DEVADDR;
      lastDevAddr=LAST_DEVADDR;
   } else
   {
      firstDevAddr=message.devAddr;
      lastDevAddr=message.devAddr;
   }
   comError=0;   // reset only once each pass through this routine
                  // so that 1 bad device & 1 good device still flags error
   for (i=firstDevAddr; i<=lastDevAddr; i++)
   {  if ( (1 << (i-1)) & availableDevices )  // if i is a remote devAddr
      {
         // set device id
         message.devAddr=i;
         if (i != firstDevAddr) msDelay(2);   // wait for data lines to clear
         retry=3;
         good=FALSE;
         while (!good && retry)
         {
            if (send_command(message))
            {  // sent command ok, now get response
               workmsg.command=0;   // clear for input of response
               get_response(&workmsg);
               if (workmsg.command==message.command)
               {  // OR all the input responses together
                  // for (j=0; j<4; j++) response->data[j] |= workmsg.data[j];
                  if (workmsg.devAddr==SLAVE_DEVADDR && workmsg.command==RETURN_INPUTS)
                  {  // store slave return_input data in global array
   		            for (j=0; j<NUMDATA; j++) slaveData[j] = workmsg.data[j];
                  }
                  else
                  {  for (j=0; j<NUMDATA; j++) response->data[j] |= workmsg.data[j];
                  }
                  response->devAddr |= workmsg.devAddr; // only works for 1 device at a time (1 << workmsg.devAddr-1);  // return responders as bit-wise
                  response->station |= workmsg.station;
                  response->command = workmsg.command;
                  good=TRUE;
                  anygood=TRUE;
                  // if extended data command then store data in alternate location
                  if (workmsg.command==RETURN_EXTENDED) for (j=0; j<4; j++) extendedData[i][j]=workmsg.data[j];
               } else retry--;
            } else retry--;
         }
         if (!good) comError |= 1<<(i-1);   // set flag on failed communications
      }
   }

   return anygood;
}

char get_response(struct iomessage *message)
{
   char i, status;
   char rcvbuf[CMD_LENGTH];
   int rcvcount;
   char cksum;
   unsigned long tstart;

   message->command=0;  /* assume no response for now */

   /* enable the receiver to get cmdlen characters */
   ser485Rx();  // should have been done already
   // rcvcount = CMD_LENGTH;
	t3=MS_TIMER;      // debug
   //ser_rec_z1(rcvbuf, &rcvcount);

   // align frame to <STX>
   while ((serDrdUsed() > 0) && (serDpeek() != STX)) printf("gr tossing %d\n",serDgetc());

   rcvcount = 0;
   tstart = MS_TIMER;
   while (rcvcount==0 && (MS_TIMER - tstart < RCV_TIMEOUT))
      rcvcount = serDread(rcvbuf, CMD_LENGTH, RCV_TIMEOUT);

	t4=MS_TIMER;      // debug
   if (rcvcount != CMD_LENGTH)
   {  /* not all characters received */
      // ser_kill_z1();       /* disable and return failure */
      ++commstat[5];       // increment status counter
	   #ifdef PRINT_ON
	      printf("\n INCOMPLETE INPUT: (%d) ",rcvcount);
	      for (i=0; i<rcvcount; i++) printf(" %d", rcvbuf[i]);
	   #endif
      status=FALSE;
   } else
   {  /* got the right number of characters */
      if ( (rcvbuf[0] != STX)
      || (rcvbuf[CMD_LENGTH-2] != ETX))
      {
		    ++commstat[6];       // increment status counter
	      #ifdef PRINT_ON
	         printf("\n BAD INPUT: No STX %d and/or ETX %d", rcvbuf[0],rcvbuf[CMD_LENGTH-2]);
	      #endif
		   status=FALSE;
      }
      else
      {  /* check the checksum */
	   	cksum=0;
	      for (i=0; i<CMD_LENGTH-1; i++) cksum += rcvbuf[i];

    		if (cksum != rcvbuf[CMD_LENGTH-1])
			{  /* bad checksum */
      		++commstat[4];       // increment status counter
	         #ifdef PRINT_ON
	           printf("\n CHECKSUM ERROR: Calculated %d not equal to xmitted %d",cksum, rcvbuf[CMD_LENGTH-1]);
	         #endif
	         status=FALSE;
	      }
	      else
	      {  /* command is good */
	         ++commstat[3];       // increment status counter - # returned
	         message->devAddr = rcvbuf[1];
	         message->command = rcvbuf[2];
	         message->station = rcvbuf[3];
		      for (i=0; i<NUMDATA; i++) message->data[i]=rcvbuf[i+4];
	         status=TRUE;
	      }
      }
   }
//printf(" :: %ld  %ld  %ld \n", t2-t1, t3-t2, t4-t3);    // debug
   return status;
}
/******************************************************************/
char txcounter;
char send_command(struct iomessage message)
{  /* Transmits a message/command to the remote system(s).
      Command string defined as:
      <STX> <devAddr> <Command> <Station> <Data0..3> <ETX> <CHKSUM> */

   // Set <devAddr> = ALL_DEVICES to transmit command to all devices

   char i,good,retry;
   char cmdstr[CMD_LENGTH];
   char cmdlen;
   char rcvbuf[CMD_LENGTH];
   unsigned long timeout, cmdsent;
   char mybuf[100];
   char tmpbuf[10];
   int bufchrs;
//unsigned long t1, t2;
   mybuf[0]=0;

   good=0;                        /* return value -- assume nogood*/
   retry=3;

   ++commstat[0];       // increment status counter -- total sent

   hitwd();             // hit watchdog incase comm loop
//msDelay(5);
   while (!good && retry)
   {
      // enable transmitter a bit sooner
      ser485Tx();

      /* assemble the full command string */
      cmdlen = CMD_LENGTH;
      cmdstr[0] = STX;
      cmdstr[1] = message.devAddr;                       // one or all devices
      cmdstr[2] = message.command;
      cmdstr[3] = message.station;
      for (i=0; i<NUMDATA; i++) cmdstr[i+4]=message.data[i];
      cmdstr[cmdlen-2] = ETX;
      cmdstr[cmdlen-1] = 0;
      for (i=0; i<cmdlen-1; i++) cmdstr[cmdlen-1] += cmdstr[i]; /* checksum */

      // enable transmitter and send
      //ser485Tx();
      cmdlen = serDwrite(cmdstr, CMD_LENGTH);
      disable485whenDone();
//t1 = MS_TIMER;
      // get ack if sending to one device
      if (message.devAddr != ALL_DEVICES)
      {  // try to throw out first character in case of immediate junk
	      // cmdlen = serDread(rcvbuf, 1, 0);
         /* should get an ACK or NAK within a short timeout */
         rcvbuf[0]=0;
         cmdlen=0;                       // one character answer
         timeout = MS_TIMER;
	      //serDrdFlush(); // try to flush the read buffer again
         while ((rcvbuf[0] != ACK) && (rcvbuf[0] != NAK) && (MS_TIMER - timeout < ACK_TIMEOUT))
         	cmdlen = serDread(rcvbuf, 1, 0);
//t2 = MS_TIMER;
//printf("\n%ld\n", t2-t1);
         // pre check for ACK, NAK and if not try getting another character
         //if ((cmdlen) && (rcvbuf[0] != ACK) && (rcvbuf[0] != NAK))
         //   { cmdlen = 0;
		   //      while (cmdlen==0 && (MS_TIMER - timeout < ACK_TIMEOUT))
		   //         cmdlen = serDread(rcvbuf, 1, 0);
         //   }

//   printf("it took %ld ms to get %d response %d\n", MS_TIMER-timeout, cmdlen, rcvbuf[0]);
//   if (rcvbuf[0] != ACK) {msDelay(1); printf("peeking at %d\n", serDpeek());}

         if (rcvbuf[0] == ACK)         // received and acknowleged
         {  good = 1;                  // TRUE
         }
         else if (rcvbuf[0] == NAK)    // Not received properly
         {
       		++commstat[8];             // increment status counter
				//if (PRINT_ON) printf("NAK  ");
	         #ifdef PRINT_ON
	           strcat(mybuf,"NAK ");
	         #endif
         }
         else if (rcvbuf[0])           // Unknown response
         {
       		++commstat[7];             // increment status counter
				//if (PRINT_ON) printf("DK  ");
				#ifdef PRINT_ON
               strcat(mybuf,"DK ");
               itoa((int)rcvbuf[0], tmpbuf);
               strcat(mybuf,tmpbuf);
            #endif
         }
         else                          // No response
         {
       		/* Re-initialize serial port 1 */
       		//ser_init_z1(4, 19200/1200);
            //serDclose();
            //serDopen(BAUD_RATE);
            ++commstat[9];                                  // increment status
				//if (PRINT_ON) printf("NIL  ");
				#ifdef PRINT_ON
            	strcat(mybuf,"NIL ");
            #endif
         }
         --retry;
      } else good = 1;
   }
   // Update communication statistics and flags
   if (good) { ++commstat[1]; }   // don't reset comError flag here
   else { ++commstat[2]; }

	#ifdef PRINT_ON
      if (strlen(mybuf) > 0) printf("%ld %s\n",SEC_TIMER, mybuf);
   #endif

   return good;
}
/********************************************************/
// slave com functions
/********************************************************/
void slaveEnableCommands()
{  // open serial port D
   serDopen(BAUD_RATE);
	ser485Rx();			// enable the receiver
   serDrdFlush(); 	// flush the read buffer
}
char slaveComActive()
{ if (SEC_TIMER - lastComTime > 2) return FALSE;
  else return TRUE;
}
/********************************************************/
void slaveSendResponse(struct iomessage message)
{  /* Transmits a message/command to the main system.
      Command string defined as:
      <STX> <lplc> <Command> <Station> <Data0..4> <ETX> <CHKSUM> */

   char i;
   char cmdstr[CMD_LENGTH];
   char cmdlen;
   char rcvbuf[CMD_LENGTH];
   char rcvlen;
   unsigned long timeout, cmdsent;
   cmdlen=CMD_LENGTH;

   // enable transmitter
   ser485Tx();

   /* formulate the full command string */
   cmdstr[0] = STX;
   cmdstr[1] = SLAVE_DEVADDR;
   cmdstr[2] = message.command;
   cmdstr[3] = message.station;
   for (i=0; i<NUMDATA; i++) cmdstr[i+4]=message.data[i];
   cmdstr[cmdlen-2] = ETX;
   cmdstr[cmdlen-1] = 0;
   for (i=0; i<cmdlen-1; i++) cmdstr[cmdlen-1] += cmdstr[i]; /* checksum */

   // send
   cmdlen = serDwrite(cmdstr, CMD_LENGTH);
   if (cmdlen != CMD_LENGTH) printf("Send command failed, only sent %d chars \n", cmdlen);

   disable485whenDone();

}
/********************************************************/
char slaveGetCommand(struct iomessage *message)
{
/* Repeatedly call this function to process incoming commands efficiently. */
   char charsinbuf, msg_address;
   char rtnval, chksum, i;
	#define rbuflen      30
	#define sbuflen      5
	#define SLAVE_RCV_TIMEOUT 1
	static char rbuf[rbuflen], sbuf[sbuflen];
	static char bufstart;

   rtnval=FALSE;     /* assume none for now */

   // align frame to <STX>
   while ((serDrdUsed() > 0) && (serDpeek() != STX)) printf("%ld tossing %d\n",MS_TIMER, serDgetc());

   // if at least 1 command in buffer then get them
   if (serDrdUsed() >= CMD_LENGTH)
	   charsinbuf = serDread(rbuf, CMD_LENGTH, SLAVE_RCV_TIMEOUT);

   bufstart = 0;
   if (charsinbuf==CMD_LENGTH)  /* all characters received */
   {
	   /* verify STX, ETX, checksum then respond */
	   if ((rbuf[bufstart] == STX) && (rbuf[bufstart+CMD_LENGTH-2] == ETX))
	   {
	      /* check checksum */
	      chksum=0;
	      for (i=0; i<CMD_LENGTH-1; i++) chksum+=rbuf[bufstart+i];

	      if (chksum != rbuf[bufstart+CMD_LENGTH-1])
	      {
	         sbuf[0]=NAK;
	         rtnval=FALSE;
	      }
	      else
	      {
	         /* looks good, send ACK */
	         sbuf[0]=ACK;
	         rtnval=TRUE;
	      }
         lastComTime = SEC_TIMER;
	      msg_address = rbuf[bufstart+1];
	      // send response if message is addressed to me only
	      if (msg_address==SLAVE_DEVADDR)
         {
	         // enable transmitter and send
	         ser485Tx();
         	serDwrite(sbuf, 1);
			   disable485whenDone();
         }

	      // If this message for me OR everyone then process it.
	      if ((msg_address==SLAVE_DEVADDR) || (msg_address==ALL_DEVICES))
	      {  // message for me (and possibly others)
	         /* return the command for processing */
	         message->devAddr=msg_address;
	         message->command=rbuf[bufstart+2];
	         message->station=rbuf[bufstart+3];
		      for (i=0; i<NUMDATA; i++) message->data[i]=rbuf[i+bufstart+4];

	      } else rtnval=FALSE;  // command not for me!

         //serDrdFlush(); // flush the read buffer

	   }
   }
   return rtnval;
}


void show_comm_status()
{
   static unsigned long updateclock;
   char eventMsg[40];

   #GLOBAL_INIT
   {  updateclock = 0; }

   // now=SEC_TIMER;

   if (SEC_TIMER > updateclock)
   {
      updateclock=SEC_TIMER+2;

      // put up or remove communications status message
      if (comError)
      {  sys_message[MSG_NOCOMM+1].msg[14]=48+firstBit(comError);  // show device #
         message_add(SYSTEMLCD, MSG_NOCOMM, MSG_NOCOMM+1, NEXT);
      }
      else message_del(SYSTEMLCD, MSG_NOCOMM, MSG_NOCOMM+1);
   }
   // else if (updateclock-2 > SEC_TIMER) updateclock=SEC_TIMER;  // means updateclock is grossly out of whack

   // log to printer on failure and restore
   if ((comError!=0) && (wasComError==0))
   {   // error occured now
   	strcpy(eventMsg, "LOST REMOTE COMMUNICATIONS @ DEV #");
      eventMsg[33]=48+firstBit(comError);
      print_event(eventMsg);
      wasComError=comError;
   } else if ((wasComError!=0) && (comError==0))
   {  // error cleared now
      print_event("REMOTE COMMUNICATIONS RESTORED");
      wasComError=comError;
   }
}

void show_comm_test(char wait)
{  // Show communication statistics on the LCD display
   char i, msgbuf[16];
   char y;

   if (wait)
   {  lcd_drawScreen(5, "COMMUNICATIONS");
	   lcd_Font("16B");
   }
   y=60;
   // loop through each statistic
   for (i=0; i<CSTATS; i++)
   {
      if (commstat[i])        // only show if non-zero
      {
        //lputs(0, commlbl[i]);		// write the descriptive label
        ltoa(commstat[i],msgbuf);
        //lputs(1,"                ");
        //lputs(1, msgbuf);			// write the statistic value
        if (wait)
        {  lcd_DispText(commlbl[i], 20, y, MODE_NORMAL);
	        lcd_DispText(msgbuf, 160, y, MODE_NORMAL);
	        y=y+20;
        } else // show on plain screen
        {  lcd_DispText(commlbl[i], 0, 0, MODE_NORMAL);
	        lcd_DispText("  ", 0, 0, MODE_NORMAL);
	        lcd_DispText(msgbuf, 0, 0, MODE_NORMAL);
	        lcd_DispText("\n", 0, 0, MODE_NORMAL);
        }
        //msDelay(1500);
      }
   }
   if (wait) // wait for any button press or timeout
	{  menu_timeout = SEC_TIMER + 60;
	   while( (lcd_GetTouch(100) == -1) && !secTimeout(menu_timeout) ) maintenance();
   }
   else
   	msDelay(1500);
}
/******************************************************************/
void checkRemoteConfiguration(void)
{  // determine which remotes are connected to the bus

   struct iomessage testcmd, testrsp;
   char i, workset, mymsg[20], mybuf[10];
   int j;

   slaveAvailable = FALSE;  // ASSUME NOT
   FIRST_DEVADDR=0;   // number
   LAST_DEVADDR=0;    // number
   workset=0;
   //ALL_DEVADDRS=((1 << MAX_DEVADDRS) - 1 ) | 0x80; // bits ... including high bit
   availableDevices = 0xFF;  // address all possible devices

   //lcd_print(SYSTEMLCD, 0, " CHECKING REMOTE");
   //lcd_print(SYSTEMLCD, 1, " CONFIGURATION  ");
	lcd_DispText("Detecting Remote Devices\n",0, 0, MODE_NORMAL);
   // hold for a few seconds
   //msDelay(100);

   strcpy(mymsg, "  ");
   STATION_SET = 0;                  // startoff with none
   for (j=1; j<=MAX_DEVADDRS; j++)
   {  mybuf[0]=48+j; mybuf[1]=32; mybuf[2]=0;
	   lcd_DispText(mybuf, 0, 0, MODE_NORMAL);
      hitwd();
      testcmd.station=0;
      testcmd.devAddr=j;
      testcmd.data[0]=0;  // main ok to receive
      testcmd.data[1]=IDLE_STATE;  // system state
      testcmd.data[2]=0; // slave inUse ON
      testcmd.data[3]=0; // slave inUse Flash
      testcmd.data[4]=STATION_SET; // who's available
      testcmd.command=RETURN_INPUTS;
      msDelay(100);       // seems to improve communications
      i = send_n_get( testcmd, &testrsp );      // are you alive
      if (testrsp.devAddr==testcmd.devAddr)
      {  // this one is alive
         STATION_SET |= testrsp.station;        // who do you own
         if (FIRST_DEVADDR==0) FIRST_DEVADDR=j;
         LAST_DEVADDR=j;
			// if (testrsp.station & SLAVE_b) slaveAvailable=TRUE;
			if (testrsp.devAddr == SLAVE_DEVADDR) slaveAvailable=TRUE;
         workset |= (1 << (j-1));                // include this bit
         itoa(j, mybuf);
         strcat(mymsg, " #");
         strcat(mymsg, mybuf);
      }
   }
   STATION_SET &= param.activeStations;  // allow only those programmed in diag menu
   availableDevices = workset; // | 0x80;     // also set high bit, meaning ALL

   if (strlen(mymsg) <= 3) strcpy(mymsg, "- NONE -");

   // pad the message buffer
   //for (j=strlen(mymsg); j<16; j++) strcat(mymsg, " ");

   // show the results of the query
   //lcd_print(SYSTEMLCD, 0, "RESPONSE OK FROM");
   //lcd_print(SYSTEMLCD, 1, mymsg);
   lcd_DispText("\nResponse Received From ",0, 0, MODE_NORMAL);
   lcd_DispText(mymsg,0, 0, MODE_NORMAL);
   lcd_DispText("\n", 0, 0, MODE_NORMAL);

   // reset communications statistics
   init_communication();

   // hold for a few seconds
   //msDelay(2000);
}

nodebug void reset_statistics()
{
   // reset system statistics
   statistics.trans_in=0;
   statistics.trans_out=0;
   statistics.deliv_alarm=0;
   statistics.divert_alarm=0;
   statistics.cic_lift_alarm=0;
}

void time2string(unsigned long time, char *buf, int format)
{  // Converts the time value into a string as specified by format
   // time    time value to be converted
   // buf     destination string ... make sure you allocate enough room
   // format  how the time should be converted
   //         1 = HH:MM:SS     2 = HH:MM
   //         3 = MM/DD/YY     4 = MM/DD/YY HH:MM:SS

   struct tm mytime;
   char * myptr;

   // convert long time to structure
   mktm( &mytime, time);
   myptr=buf;

   // convert date
   if (format==3 || format==4)
   {
      // fill in the date values
      *myptr++ = 48 + (mytime.tm_mon / 10);
      *myptr++ = 48 + (mytime.tm_mon % 10);
      *myptr++ = '/';
      *myptr++ = 48 + (mytime.tm_mday / 10);
      *myptr++ = 48 + (mytime.tm_mday % 10);
      *myptr++ = '/';
      *myptr++ = 48 + ((mytime.tm_year / 10) % 10);
      *myptr++ = 48 + (mytime.tm_year % 10);

   }

   // convert time
   if (format==1 || format==2 || format==4)
   {
      if (format==4) *myptr++ = 32;   // space seperator

      // fill in the time values
      *myptr++ = 48 + (mytime.tm_hour / 10);
      *myptr++ = 48 + (mytime.tm_hour % 10);
      *myptr++ = ':';
      *myptr++ = 48 + (mytime.tm_min / 10);
      *myptr++ = 48 + (mytime.tm_min % 10);

      if (format==1 || format==4)  // format seconds
      {  *myptr++ = ':';
         *myptr++ = 48 + (mytime.tm_sec / 10);
         *myptr++ = 48 + (mytime.tm_sec % 10);
      }
   }

  *myptr = 0;    // null terminator

}

/******************************************************/
// Printout functions
/******************************************************/
void print_event(char *event)
{
   char myline[80];     // line to send to the printer
   char * instr;        // work pointer into myline

   instr=myline;
   time2string(SEC_TIMER, instr, 4);      // event time
   strcat(myline, " ");
   strcat(myline, event);
///   reset_printer();  // reset/retry printer each time
///   print_line(myline);
	printf("\n"); printf(myline);

}

void print_malfunction(struct trans_log_type log)
{
   char myline[80];     // line to send to the printer
   char * instr;        // work pointer into myline


   strcpy(myline, "ALARM ");
   instr=myline+strlen(myline);
   time2string(log.end_tm, instr, 4);      // malfunction time
   strcat(myline," ");
   instr=myline+strlen(myline);
   switch (log.status & 0x0F)
   {
   case STS_DIVERTER_TOUT: strcat(myline, "DIVERTER TIMEOUT");		break;
   case STS_DEPART_TOUT: 	strcat(myline, "DEPARTURE TIMEOUT");	break;
   case STS_ARRIVE_TOUT: 	strcat(myline, "DELIVERY OVERDUE");   	break;
   case STS_BLOWER_TOUT: 	strcat(myline, "BLOWER TIMEOUT");     	break;
   case STS_TRANS_CANCEL: 	strcat(myline, "CANCEL DISPATCH");    	break;
   //case 5: strcat(myline, "COMMUNICATIONS LOST"); 	break;
	}

///   reset_printer();  // reset/retry printer each time
///   print_line(myline);

   // print_transaction( log );  // now print normal log

}


void print_transaction(struct trans_log_type log)
{
   char myline[80];     // line to send to the printer
   char * instr;        // work pointer into myline
   long transtime;      // how long transaction took

   // format the message line
   time2string(log.start_tm, myline, 4);      // start time
   strcat(myline," ");
   instr=myline+strlen(myline);
   sprintf(instr, "%-12s", param.station_name[log.source_sta].name);
   strcat(myline, "-->> ");
   instr=myline+strlen(myline);
   time2string(log.end_tm, instr, 1);
   transtime=log.end_tm-log.start_tm;
   instr=myline+strlen(myline);
   sprintf(instr, " %-12s %4ld sec", param.station_name[log.dest_sta].name, transtime);

///   reset_printer();  // reset/retry printer each time
///   print_line(myline);
}
/******************************************************/
const char prLine[] = "-----------------------------------------------------------------";
void print_summary(struct stats_type stats, char how)
{
   // stats  :  system summary statistics
   // how    :  automatic report (0) or on-demand report (1)

   char myline[80];     // line to send to the printer
   char * instr;        // work pointer into myline
   long subtot;         // total of transactions or alarms
/*
   reset_printer();  // reset/retry printer each time
   print_line(prLine);
   print_line(station_name[SYSTEM_NAME].name);  // print system name
   if (how==0) {   strcpy(myline, "  Daily ");
   } else { strcpy(myline, "  On-Demand "); }
   strcat(myline, "Transaction Summary Printed ");
   instr = myline + strlen(myline);
   time2string(clock(), instr, 4);
   print_line(myline);
   print_line(prLine);
   print_line(" Transactions:");
   sprintf(myline, "    Incoming:              %ld", stats.trans_in);
   print_line(myline);
   sprintf(myline, "    Outgoing:              %ld", stats.trans_out);
   print_line(myline);
   sprintf(myline, "    Daily Total:           %ld", stats.trans_in + stats.trans_out);
   print_line(myline);
   sprintf(myline, "    Grand Total:           %ld", transactionCount());
   print_line(myline);
   print_line(" ");
   print_line(" Alarms:");
   sprintf(myline, "    Incomplete Delivery:   %d", stats.deliv_alarm);
   print_line(myline);
   sprintf(myline, "    Diverter Timeout:      %d", stats.divert_alarm);
   print_line(myline);
   sprintf(myline, "    Other Timeouts:        %d", stats.cic_lift_alarm);
   print_line(myline);
   subtot=stats.deliv_alarm+stats.divert_alarm+stats.cic_lift_alarm;
   sprintf(myline, "    Total:                 %ld", subtot);
   print_line(myline);
   print_line(prLine);
*/
}

void check_auto_report(struct stats_type stats)
{

   if (SEC_TIMER >= nextAutoPrint)
   {
      // time to print automatic summary report
      print_summary(stats, 0);

      // increment to next day (86400 seconds per day)
      while (nextAutoPrint <= SEC_TIMER) { reset_auto_print(); }

      // reset statistics
      reset_statistics();
   }
}
void reset_auto_print()
{  // set auto print statistics for midnight tomorrow
   nextAutoPrint = (((SEC_TIMER+1) / 86400) +1) * 86400;
}

//*************************************
// functions for master/slave operation
//*************************************
void syncDateAndTime()
{  // for master to send the date/time to the slave
   struct iomessage command;
	struct tm time;
   tm_rd(&time);  // get the time from the RTC

   command.devAddr=ALL_DEVICES;
   command.command=SET_DATE_TIME;
   command.station=0;
   command.data[0] = time.tm_year;
   command.data[1] = time.tm_mon;
   command.data[2] = time.tm_mday;
   command.data[3] = time.tm_hour;
   command.data[4] = time.tm_min;
   send_command(command);
}
void syncTransCount()
{  // for master to send traction count to slave
   struct iomessage command;
   char *p;

   p=(char*)&transaction_count;

   command.devAddr=ALL_DEVICES;
   command.command=SET_TRANS_COUNT;
   command.station=0;
   command.data[0] = *p++;
   command.data[1] = *p++;
   command.data[2] = *p++;
   command.data[3] = *p;
   command.data[4] = 0;
   msDelay(5);  // just sent a command so wait a bit
   send_command(command);
}
void displayRemoteMsgs(char * message_num)
{  // for master to send lcd messages to slave
   struct iomessage command;
   char i;

   command.devAddr = ALL_DEVICES;
   command.command = DISPLAY_MESSAGE;
   for (i=0; i<4; i++) command.data[i]=message_num[i];

   send_command(command);
}
void deliverComControl(char *sys_state)
{  // let slave use the comm for a while
   struct iomessage mymsg;
   char waiting;

   param.slaveController=SLAVE; // TEMP ID

   // tell slave ok
   mymsg.command=TAKE_COMMAND;
   mymsg.devAddr=SLAVE_DEVADDR;
   mymsg.data[0]=*sys_state;
   mymsg.data[1]=availableDevices;
   mymsg.data[2]=remote_data[REMOTE_CIC];
   send_command(mymsg);

   // display lcd message
   lcd_printMessage(2, " SLAVE IN USE   ");
   lcd_printMessage(3, " PLEASE WAIT... ");

   // setup diverter at master for slave to purge
   set_diverter(SLAVE);

   // wait for response
   waiting=TRUE;
   slaveEnableCommands();
   lastComTime=SEC_TIMER;
   while (waiting)
   {
      check_diverter();
      maintenance();

      if (slaveGetCommand(&mymsg))
      {  if ( (mymsg.command==TAKE_COMMAND) || (mymsg.command==RESET) )
         {  waiting=FALSE;
            *sys_state=mymsg.data[0];
         }
         lastComTime=SEC_TIMER;
      }
      if (SEC_TIMER - lastComTime > 60) waiting=FALSE;  // timeout if no com for 60 seconds
   }
   param.slaveController=MASTER; // RESET Address

}

void slaveSyncTransCount(char *p)
{  // for slave to sync transaction count from master
   char *myp;
   myp=(char*)&transaction_count;
   *myp++ = *p++;
   *myp++ = *p++;
   *myp++ = *p++;
   *myp++ = *p++;
   setCountMessage();
   root2xmem( transCountXaddr, &transaction_count, 4);
}
void slaveFinishTransaction()
{
   do_alert(OFF); //, station2bit(systemStation));
   // set arrival alert if the transaction is to here
   if ( ((system_direction == DIR_RETURN) && (mainStation==SLAVE))
       || ((mainStation==MASTER) && (main2main_trans==DIR_SEND)) )
   {
      //inUse(FLASH, station2bit(message.station));  // until no cic
      slave_arrival = SEC_TIMER;                      // to flash inuse
      rts_latch=0;   // don't allow any out-bounds right now
   }

   mainStation=0; systemStation=0;
   system_direction=0;
   arrivalEnable(OFF);
}
int slaveButton;
void slaveProcessIO()
{  // for slave to handle local I/O processing
   struct iomessage message;
   char k;   // temporary work value
   char menu_item;
   char key;
   int button;
   static char lastDirectory;		// for showing stations on the lcd

   #GLOBAL_INIT
   {
   	lastDirectory = 0;
   }

   // check for and process communications
   if (slaveGetCommand(&message)) slaveProcessCommand(message);

   slaveProcessState();      // operate on system_state

   // process local i/o
   check_diverter();
   //processCycleTime();
   //key = getKey(); // processKeyInput();
   // handle button press
   button = lcd_GetTouch(1);
   if (button != -1)
   {  slaveButton = button;  // save this button press
   	if (!slaveComActive()) lcd_processTouchScreen(slaveButton);
   	else slaveReturnStatus |= 0x08; // let master decide if I can do this
   }

   if (slave_arrival)
   {
     // check for 10 second arrival alert signal
     if (system_state != HOLD_TRANSACTION)   // except when holding
     {  if ( (SEC_TIMER - slave_arrival) %20 >= 10 ) do_alert(ON);
        else do_alert(OFF);
     }

     // check to clear main arrival alert when door opens or another transaction starts
     if ( (!di_doorClosed && !di_carrierInChamber)
         || ((mainStation==SLAVE) && (system_direction==DIR_SEND)) )
     {  slave_arrival=0;
        arrival_from=0;
        do_alert(OFF);
     }
   }

   lcd_showCIC(0);  // show CIC

   // latch transaction requests ... only if there is a carrier or carrierReturn
   k=di_requestToSend; // | station2bit(lcd_sendTo());
   if (di_carrierInChamber || di_returnCarrier) { rts_latch |= (k & STATION_SET); }
   else if (system_state==IDLE_STATE)
   {  rts_latch=0;
      // check for directory display
      if (k != lastDirectory)
      {  //systemStationb=k;
         systemStation=bit2station(k); //systemStationb);
         if (systemStation)
	      { //lcd_print(TRANSLCD, 0, sys_message[MSG_REMOTESTA].msg);
           //lcd_print(TRANSLCD, 1, sys_message[MSG_AT+systemStation].msg);
           currentmsg[TRANSLCD][0]=MSG_REMOTESTA;
           currentmsg[TRANSLCD][1]=MSG_AT+systemStation;
           lcd_displayMsgs(&currentmsg[0][0]);
         }
         lastDirectory = k;
         systemStation=0;  // reset this after directory display
      }
   }
}
void slaveProcessCommand(struct iomessage message)
{
   char wcmd, wdata, source, dest;
   char ok, i, j;
   struct iomessage response;
   struct tm time;
   response.command=0;
   response.station=message.station;   // set initial default

   /* determine what type of command */
   switch(message.command)
   {
   case CANCEL_PENDING:
	   rts_latch = 0;	// clear latch for all stations
	   break;

   case SET_STATION_NAME:
	   if (message.station==69)
	   {  // construct messages and save parameters to flash
	      buildStationNames();
			writeParameterSettings();
	   } else
      {  // save chunk of name
	      i=message.data[0];
	      for (j=0; j<4; j++) param.station_name[message.station].name[i+j] = message.data[j+1];
	   }
	   break;

   case SET_PHONE_NUMS:
	   if (message.station==69)
	   {  // save parameters to flash
			writeParameterSettings();
	   } else
      {  // save chunk of name
	      i=message.data[0];
	      for (j=0; j<4; j++) param.phoneNum[message.station][i+j] = message.data[j+1];
	   }
	   break;

   case SET_TRANS_COUNT:
	   slaveSyncTransCount(&message.data[0]);
	   break;

   case SET_DATE_TIME:
	   tm_rd(&time);  // read all time data
	   time.tm_year=message.data[0];
	   time.tm_mon=message.data[1];
	   time.tm_mday=message.data[2];
	   time.tm_hour=message.data[3];
	   time.tm_min=message.data[4];
	   tm_wr(&time);  // write new time data
      SEC_TIMER = mktime(&time);   // resync SEC_TIMER
	   break;

   case DISPLAY_MESSAGE:
	   // display messages on lcd if installed
	   // first update variable messages
	   setCountMessage();
	   setTimeMessages(MSG_DATE_TIME, SEC_TIMER);
	   // fixup messages in function_mode at master
	   if (message.data[0] == MSG_FUNCTION)
	   {  message.data[2]=MSG_WAIT;
			message.data[3]=MSG_BLANK;
	   }
	   //lcd_print(TRANSLCD, 0, sys_message[message.data[0]].msg);
	   //lcd_print(TRANSLCD, 1, sys_message[message.data[1]].msg);
	   //lcd_print(SYSTEMLCD, 0, sys_message[message.data[2]].msg);
	   //lcd_print(SYSTEMLCD, 1, sys_message[message.data[3]].msg);
      lcd_displayMsgs(&message.data[0]);

	   break;

   case ARE_YOU_READY:  // ready to begin transaction
	   // need to check for both source and destination stations
	   lcd_drawScreen(1,lcd_NO_BUTTONS);  // take away buttons
	   response.command=ARE_YOU_READY;
	   systemStation=message.station;
	   systemStationb=station2bit(systemStation);
	   system_direction=message.data[0];
	   mainStation=message.data[1];
	   main2main_trans=message.data[2];

	   // clear latch for these stations
	   rts_latch &= ~systemStationb;

	   response.data[0]=SLAVE_b;     // assume ready for now

	   // check destination station ... is it me?
      // 1) main to slave
      if ((mainStation==MASTER) && (main2main_trans==DIR_SEND))
      { // door must be closed, set arrival enable
      	if (di_doorClosed)
         {  arrivalEnable(ON);
         } else
         {  // door open so not ready
            response.data[0]=0;           // not ready
	         do_alert(ON);
         }
      }
      // 2) remote to slave
      else if ((mainStation==SLAVE) && (system_direction==DIR_RETURN))
      { // door must be closed, set arrival enable
      	if (di_doorClosed)
         {  arrivalEnable(ON);
         } else
         {  // door open so not ready
            response.data[0]=0;           // not ready
	         do_alert(ON);
         }
      }
      // 3) slave to any
      else if ((mainStation==SLAVE) && (system_direction==DIR_SEND))
      { // door must be closed, carrier in chamber
      	if (di_doorClosed && di_carrierInChamber)
         {  // do nothing, ready to go
         } else
         {  // door open or no carrier so not ready
            response.data[0]=0;           // not ready
	         do_alert(ON);
         }
      }
      // 4) don't care, always ready
      else
      {
        // do nothing
      }
		break;

   case SET_DIVERTER:
	   mainStation=message.data[1];
	   // set_diverter(mainStation);  NEVER A SLAVE LOCAL DIVERTER
	   break;

   case DIVERTER_STATUS:      /* return logic of correct position */
	   response.command=DIVERTER_STATUS;
	   mainStation=message.data[1];
      response.data[0]=SLAVE_b;  // NEVER A SLAVE LOCAL DIVERTER, ALWAYS OK TO GO
   /* NEVER A SLAVE LOCAL DIVERTER
      if ( (di_diverterPos == diverter_map[mainStation])
        || (diverter_map[mainStation]==0)
        || (param.localDiverter==FALSE) )
      {  response.data[0]=SLAVE_b; // DIVERTER_READY;
      } else
      {  response.data[0]=0;     // DIVERTER_NOT_READY;
         set_diverter(mainStation);
      }
   */
	   break;

   case RETURN_INPUTS:        /* return general status */
	   system_state=message.data[1];   // set system_state
	   response.command=INPUTS_ARE;
	   response.station=SLAVE_b;  // return this to enlighten main
	   response.data[0] = di_carrierInChamber ? 0x01 : 0;
	   if (di_doorClosed) response.data[0] |= 0x02;
	   if (latchCarrierArrival) response.data[0] |= 0x04;
	   if (di_priorityRequest || (btnStatFlag==1)) response.data[0] |= 0x08;
      if (btnStatFlag==2) response.data[0] |= 0x10;
      btnStatFlag=0; // reset the flag
	   //response.data[0] |= di_diverterPos << 4;  // why was I sending diverter pos?
	   response.data[1] = rts_latch | station2bit(lcd_sendTo());
	   if (slave_arrival) slaveReturnStatus |=0x10;  // slave arrival flag
	   if (di_returnCarrier || lcd_returnCarrier()) slaveReturnStatus |= 0x40;   // return carrier_return request
	   response.data[2]=slaveReturnStatus;
	   slaveReturnStatus=0;  // I expect immediate response

	   // return the response immediately
	   response.devAddr=SLAVE_DEVADDR;
	   slaveSendResponse(response);
	   response.command=0;

	   // set my lights based on main station
      inUse(ON, message.data[2]);
      inUse(FLASH, message.data[3]);
      inUse(OFF, ~(message.data[2]|message.data[3]));

	   STATION_SET=message.data[4];

	   // change active main if needed
	   if ( (message.station != param.activeMain)
	   && (message.station == MASTER || message.station == SLAVE))
	   {  param.activeMain=message.station;
	   	setActiveMainMsg();
	   }
      activeMainHere = (param.activeMain == MASTER); // FOR SETUP MENU - NOT-OPPOSITE OF MASTER LOGIC
		break;

   case SET_OUTPUTS:
	   break;

   case CLEAR_OUTPUTS:
	   break;

   case TRANS_COMPLETE:
      slaveFinishTransaction();
	   lcd_drawScreen(1,lcd_WITH_BUTTONS);
	   break;

   case TAKE_COMMAND:
      availableDevices=message.data[1] & 0x7F; // exclude slave (me)
      FIRST_DEVADDR=0;
      LAST_DEVADDR=0;
      for (i=0; i<7; i++)
      {  if (availableDevices & (1<<i))
      	{  if (FIRST_DEVADDR==0) FIRST_DEVADDR=i+1;
         	LAST_DEVADDR=i+1;
         }
      }
      // take CIC data too
		remote_data[REMOTE_CIC] = message.data[2];
      // process the button previously presses
	   lcd_processTouchScreen(slaveButton);
      slaveButton=-1;

	   //if (system_state==MALFUNCTION_STATE) lcd_enterSetupMode(0);
      //else lcd_enterSetupMode(1);
	   //lcd_drawScreen(1, "MENU");		// redraw main screen

	   // return command when done
	   message.command=TAKE_COMMAND;
	   message.devAddr=SLAVE_DEVADDR;  // send to main, temporary lplc#
	   message.data[0]=system_state;
	   send_command(message);
	   lastComTime=SEC_TIMER;
	   break;

   case MALFUNCTION:
	   // turn on alarm output only
	   do_alert(OFF);
	   if (mainStation==SLAVE) alarm(ON);
	   rts_latch=0;
	   for (i=0; i<NUMDATA; i++) response.data[i]=0; // clear remote i/o
	   arrivalEnable(OFF);      // disable arrival interrupt
	   break;

   case RESET:
	   // Turn off all outputs
	   lcd_drawScreen(1,lcd_WITH_BUTTONS);
	   inUse(OFF, ALL_STATIONS);           // clear local i/o
	   do_alert(OFF);
	   alarm(OFF);
	   // rts_latch=0;
	   mainStation=0;
	   systemStation=0;
	   system_direction=0;
	   for (i=0; i<NUMDATA; i++) response.data[i]=0; // clear remote i/o
	   arrivalEnable(OFF);      // disable arrival interrupt
	   slave_arrival=0;
	   arrival_from=0;
	   break;
   }

   /* send the response message if any */
   if (response.command)
   {
      response.devAddr=SLAVE_DEVADDR;
      slaveSendResponse(response);
   }
   slaveEnableCommands();
   return;
}
void slaveProcessState()
{
   static char washolding;

   // Process system states
   switch (system_state)
   {
   case IDLE_STATE:
	   if (systemStation) slaveFinishTransaction();
	   washolding=FALSE;
   	break;

   case PREPARE_SEND:      // does job for send and return
	   // turn off priority if it was on
	   priority = FALSE;
	   do_alert(OFF);
	   do_priorityLight(OFF);
	   arrivalEnable(OFF);
	   //inUse(FLASH, sub_stationb);
	   //blower(OFF);  // for slave to master headdiverter

		break;

   case WAIT_FOR_DIVERTERS:   // does job for send and return
	   // while waiting, if different request to send, cancel.
	   if (di_requestToSend && (mainStation==SLAVE)
	    && (systemStationb != di_requestToSend)
	    && (system_direction==DIR_SEND))
	       slaveReturnStatus |= 0x01;  // cancel transaction

	   break;

   case BEGIN_SEND:           // make sure all stations ready (by command)
	   //inUse(ON, sub_stationb);
	   break;

   case WAIT_FOR_MAIN_DEPART:
	   // if (mainStation==SLAVE) blower(blowerSend);
	   do_alert(OFF);
	   break;

   case WAIT_FOR_REM_DEPART:
	   if ( (mainStation==SLAVE) || ((mainStation==MASTER) && (main2main_trans==DIR_SEND)))
	   {  // blower(blowerReturn);
	      arrivalEnable(ON);      // enable arrival interrupt
	   }
	   do_alert(OFF);
	   break;

   case WAIT_FOR_HEADDIVERTER:
	   break;

	case SHIFT_HEADDIVERTER:
	   if ( (mainStation==SLAVE) || ((mainStation==MASTER) && (main2main_trans==DIR_SEND)))
	   {  // blower(blowerReturn);
	      arrivalEnable(ON);      // enable arrival interrupt
	   }
	   do_alert(OFF);
	   break;

   case WAIT_FOR_MAIN_ARRIVE:
      if (washolding && ( (mainStation==SLAVE) || ( (mainStation==MASTER) && (main2main_trans==DIR_SEND))))
	   {  // blower(blowerReturn);
	      arrivalEnable(ON);      // enable arrival interrupt
	      washolding=FALSE;
		}
      do_alert(OFF);
		break;

   case WAIT_FOR_REM_ARRIVE:
      if (washolding && ( (mainStation==SLAVE) || ((mainStation==MASTER) && (main2main_trans==DIR_SEND))))
	   {  // blower(blowerSend);
	      washolding=FALSE;
	   }
	   do_alert(OFF);
	   break;

	case HOLD_TRANSACTION:
	   // blower(OFF);
	   if (mainStation==SLAVE)
	   {  do_alert(ON); // FORCED);
		   washolding=TRUE;
	   }
	   break;

   case CANCEL_STATE:
	   inUse(OFF, systemStationb);
	   // blower(OFF);
	   arrivalEnable(OFF);
	   washolding=FALSE;
	   break;

   case MALFUNCTION_STATE:
	   // blower(OFF);
	   arrivalEnable(OFF);
	   if (mainStation==SLAVE) alarm(ON); // added 10/23/97
	   break;

   default:	 // unknown state, do nothing
   } // end switch (system_state)
}

nodebug
void msDelay(unsigned int delay)
{
   auto unsigned long start_time;
   start_time = MS_TIMER;
   //if (delay < 500) while( (MS_TIMER - start_time) <= delay );
   //else
   while( (MS_TIMER - start_time) <= delay ) hitwd();
}
nodebug char secTimeout(unsigned long ttime)
{
   return (ttime > SEC_TIMER) ? FALSE : TRUE;
}
void lcd_helpScreen(char view)
{  // view not applicable - reserved for future use
	int button;

   // Logo splash screen
	lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	lcd_ClearScreen ();
   lcd_Font("13");
   lcd_DispText(FIRMWARE_VERSION, 230, 5, MODE_NORMAL);
   lcd_DispText(param.station_name[SYSTEM_NAME].name, 10, 5, MODE_NORMAL);
   lcd_DispText("\nTo send a carrier:", 0, 0, MODE_NORMAL);
   lcd_DispText("\nInsert carrier into tube", 0, 0, MODE_NORMAL);
   lcd_DispText("\nClose the door", 0, 0, MODE_NORMAL);
   lcd_DispText("\nPress the send button for the destination", 0, 0, MODE_NORMAL);
   lcd_DispText("\nOR", 0, 0, MODE_NORMAL);
   lcd_DispText("\nTouch the Station Directory button", 0, 0, MODE_NORMAL);
   lcd_DispText("\nTouch the send button for the destination", 0, 0, MODE_NORMAL);
   lcd_DispText("\n", 0, 0, MODE_NORMAL);
   lcd_DispText("\nTouch the STAT button for priority dispatch", 0, 0, MODE_NORMAL);
   lcd_DispText("\nTouch the Return button to return a carrier", 0, 0, MODE_NORMAL);
   lcd_DispText("\nTouch the Menu button to access system features", 0, 0, MODE_NORMAL);
   lcd_DispText("\n", 0, 0, MODE_NORMAL);
   lcd_DispText("\nHelp Phone Numbers", 0, 0, MODE_NORMAL);
   lcd_DispText("\nSystem Administrator: ", 0, 0, MODE_NORMAL);
   lcd_DispText(param.phoneNum[ADMIN_PHONE], 0, 0, MODE_NORMAL);
   lcd_DispText("\nMaintenance: ", 0, 0, MODE_NORMAL);
   lcd_DispText(param.phoneNum[MAINT_PHONE], 0, 0, MODE_NORMAL);
   lcd_DispText("\nColombo Sales & Engineering: 800-547-2820  ", 0, 0, MODE_NORMAL);

	lcd_Font("16B");
   lcd_ButtonDef( BTN_CANCEL,
	   BTN_MOM,                      // momentary operation
      BTN_TYPE, BUTTON_RELEASE,
      BTN_MARGINS, 5, 330,         // set left and right margins
      BTN_SEP, 63, 43,              // set up for button sep
	   BTN_TXTOFFSET, 10, 9,
	   BTN_TLXY, 257, 205,             // starting x,y for buttons
	   BTN_TEXT, "Done",
	   BTN_BMP, BMP_med_button, BMP_med_button_dn,
	   BTN_END );

   // wait for a button press
   menu_timeout = SEC_TIMER + 60;
   while(((button=lcd_GetTouch(100)) == -1) && !secTimeout(menu_timeout) ) maintenance();

}
void lcd_splashScreen(char view)
{  // view 0 for initial startup splash (no wait)
   // view 1 for help->about splash (wait for button)
	int loop_count, i;
   char sbuf[15];

   if (view==0)
	{   for ( loop_count = 0; loop_count < 20; loop_count++)
	   {  if ( (i = lcd_Connect()) == lcd_SUCCESS ) break;
	      hitwd();          // "hit" the watchdog timer
	   }
	   //if ( i!= lcd_SUCCESS ) exit (1);     // exit if no comm with unit
	   lcd_BeepVolume ( 100 );             // default of 200 is TOO loud
	   lcd_Typematic ( 500, 330 );         // delay .5 secs, repeat 3/sec
   }

   // Logo splash screen
	lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	lcd_ClearScreen ();
	lcd_Origin( 0, 0 );
	lcd_screenSaver(LCD_BRIGHT);
	lcd_DispBitmap( BMP_COLOMBO_LOGO, 79, 30 );
   lcd_Font("16");
   lcd_DispText("Colombo Sales & Engineering", 70, 180, MODE_NORMAL);
   lcd_DispText("800-547-2820", 115, 200, MODE_NORMAL);
   if (view)
   {  //lcd_DispText("Software version ", 70, 225, MODE_NORMAL);
      lcd_Font("13");
   	lcd_DispText(FIRMWARE_VERSION, 108, 221, MODE_NORMAL);
      // show phone numbers for admin, maint, and colombo
      msDelay(4000);  // wait 4 seconds
   } else
   {
	   // Please wait message
	   msDelay(1000);
	   lcd_ClearScreen ();
	   lcd_Font("16B");
	   lcd_DispText("Colombo Sales & Engineering\n", 0, 0, MODE_NORMAL);
	   lcd_DispText("Pneumatic Tube System\n", 0, 0, MODE_NORMAL);
	   //lcd_DispText("Software version ", 0, 0, MODE_NORMAL);
	   lcd_DispText(FIRMWARE_VERSION,0, 0, MODE_NORMAL);
	   lcd_DispText(" ", 0, 0, MODE_NORMAL);
	   lcd_DispText(__DATE__, 0, 0, MODE_NORMAL);
	   //lcd_DispText("\n", 0, 0, MODE_NORMAL);
	   lcd_Font("16");
      lcd_DispText("\nAvailable extended memory ",0,0,MODE_NORMAL);
      sprintf(sbuf, "%ld\n", xavail((long *)0));
      lcd_DispText(sbuf,0,0,MODE_NORMAL);
   }
   lcd_Font("16");

}
void lcd_drawScreen(char whichScreen, char *title)
{
	// whichScreen:
   //  1: main screen with text boxes, unless title[0]=0 / ""
   //  2: menu header and bottom buttons
   //  3: menu header only
   //  4: menu header, keypad, OK, cancel
   //  5: header with exit button
   //  6: header keyboard, next, exit
   //  7: header clock up/downs, exit
   //  8: transaction log: pgup, pgdn, done
   //  9: header, keypad, next, exit
   int x, dx;
	lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	lcd_ClearScreen ();
	lcd_Origin( 0, 0 );
   lcd_Font("24");

   // draw title if needed
   if (whichScreen >=2)
   {
	   lcd_BFcolorsB( lcd_BLUE, lcd_WHITE );   // inside color
	   lcd_Rectangle(5, 5, 315, 40, 1);        // inside paint
	   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);   // border color
	   lcd_Rectangle(5, 5, 315, 40, 0);        // border paint
	   lcd_Font("24B");
	   lcd_DispText(title, lcd_Center(title, 1), 14, MODE_TRANS);
   }

   // now handle screen specific stuff
   switch (whichScreen)
   {
   case 1:
   	if (title[0] != 0) // Buttons? (any) or not ("")
      {
	      // Draw bottom buttons
	      lcd_BFcolorsD( lcd_BLACK, lcd_VLTGRAY_D );
	      lcd_Font("16B");
	      lcd_ButtonDef( BTN_MENU,
	         BTN_MOM,                      // momentary operation
	         BTN_TLXY, 5, 205,             // starting x,y for buttons
	         BTN_TYPE, BUTTON_RELEASE,
	         BTN_MARGINS, 5, 330,         // set left and right margins
	         BTN_SEP, 63, 43,              // set up for button sep
	         BTN_TEXT, "Menu",
	         BTN_TXTOFFSET, 10, 9,
	         BTN_BMP, BMP_med_button, BMP_med_button_dn,
	         BTN_END );
	      //lcd_Font("13");
	      lcd_ButtonDef( BTN_DIRECTORY,
	         //BTN_TLXY, 114, 198,
	         BTN_TLXY, 135, 198,
	         BTN_TEXT, "  Station\nDirectory",
	         BTN_TXTOFFSET, 14, 4,
	         BTN_BMP, BMP_92x40_button, BMP_92x40_button_dn,
	         BTN_END );
	      //lcd_Font("16B");
	      lcd_ButtonDef( BTN_HELP,
	         //BTN_TLXY, 257, 205,
	         BTN_TLXY, 70, 205,
	         BTN_TXTOFFSET, 12, 9,
	         BTN_TEXT, "Help",
	         BTN_BMP, BMP_med_button, BMP_med_button_dn,
	         BTN_END );

	      lcd_ButtonDef( BTN_CRETURN,
	         //BTN_TLXY, 257, 160,
	         BTN_TLXY, 70, 160,
	         BTN_TXTOFFSET, 6, 9,
	         BTN_TEXT, "Return",
	         BTN_BMP, BMP_med_grn_button, BMP_med_grn_button_dn,
	         BTN_END );

	      lcd_ButtonDef( BTN_ARETURN,
	         //BTN_TLXY, 114, 160,
	         BTN_TLXY, 135, 160,
	         BTN_TXTOFFSET, 9, 9,
	         BTN_TEXT, "Auto Return",
            BTN_BMP, BMP_92x32_button, BMP_92x32_button_dn,
	         BTN_END );

	      lcd_ButtonDef( BTN_STAT, BTN_LAT,
	         BTN_TLXY, 5, 160,
	         BTN_TYPE, priority ? BUTTON_LAT_1 : BUTTON_LAT_0,
	         BTN_TEXT, "STAT", "STAT",
	         BTN_TXTOFFSET, 12, 9, 12, 9,
	         BTN_BMP, BMP_med_yel_button, BMP_med_yel_button_dn,
	         BTN_END );

         // Show CIC light on the screen if we are also showing buttons
	      lcd_showCIC(1);
      }

	   // Draw LCD Message boxes
	   lcd_BFcolorsB( lcd_BLUE, lcd_LGREY);  // border color
	   lcd_Rectangle(5, 5, 315, 78, 0);       // border paint
	   lcd_Rectangle(5, 83, 315, 156, 0);     // border paint

      // since this screen was just cleared, for a refresh of the lcd messages
      reset_msg_timer(NOW);

      break;

   case 2:

	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_PREV,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 5, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "PgUp",
	      BTN_TXTOFFSET, 8, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
	   lcd_ButtonDef( BTN_NEXT,
	      BTN_TEXT, "PgDn",
	      BTN_END );
/*	   lcd_ButtonDef( 1,
	      BTN_TEXT, "",
	      BTN_END );
	   lcd_ButtonDef( BTN_SAVE,
	      BTN_TEXT, "",
	      BTN_END );
*/
	   lcd_ButtonDef( BTN_CANCEL,
	      //BTN_TXTOFFSET, 5, 9,
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
	      BTN_TEXT, "Done",
	      BTN_END );

   	break;
   case 3:
      break;
   case 4:

      lcd_ShowKeypad(0);

	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_OK,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 5, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_TEXT, "OK",
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_TXTOFFSET, 14, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
	   lcd_ButtonDef( BTN_CANCEL,
	      BTN_TXTOFFSET, 5, 9,
	      BTN_TLXY, 257, 205,           // starting x,y for buttons
	      BTN_TEXT, "Cancel",
	      BTN_END );
      break;
   case 5:

	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_EXIT,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "Exit",
	      BTN_TXTOFFSET, 15, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
      break;
   case 6:  // keyboard entry
      lcd_drawKeyboard();
	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_NEXT,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 5, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_TEXT, "Next",
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_TXTOFFSET, 8, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
	   lcd_ButtonDef( BTN_CANCEL,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "Exit",
	      BTN_TXTOFFSET, 15, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
      break;
   case 7:  // clock with up/downs
	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_SAVE,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "Exit",
	      BTN_TXTOFFSET, 15, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
      // print date/time message
      lcd_Font("16x32i");
	   lcd_DispText(sys_message[MSG_DATE_TIME].msg, 30, 60, MODE_NORMAL);
      // Draw up/dn buttons
      lcd_ButtonDef( 0, // month +
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY,    46, 100,             // starting x,y for buttons
	      BTN_MARGINS, 46, 264,         // set left and right margins
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_SEP, 48, 40,              // set up for button sep
	      BTN_TEXT, "+",
	      BTN_TXTOFFSET, 8, 1,
	      BTN_BMP, BMP_button_up, BMP_button_dn,
	      BTN_END );                                        // month
      lcd_ButtonDef( 2, BTN_MOM, BTN_TEXT, "+", BTN_END ); // day
      lcd_ButtonDef( 4, BTN_MOM, BTN_TEXT, "+", BTN_END ); // year
      lcd_ButtonDef( 6, BTN_MOM, BTN_TEXT, "+", BTN_END ); // hour
      lcd_ButtonDef( 8, BTN_MOM, BTN_TEXT, "+", BTN_END ); // min
      lcd_ButtonDef( 1, BTN_MOM, BTN_TEXT, "-", BTN_END );
      lcd_ButtonDef( 3, BTN_MOM, BTN_TEXT, "-", BTN_END );
      lcd_ButtonDef( 5, BTN_MOM, BTN_TEXT, "-", BTN_END );
      lcd_ButtonDef( 7, BTN_MOM, BTN_TEXT, "-", BTN_END );
      lcd_ButtonDef( 9, BTN_MOM, BTN_TEXT, "-", BTN_END );
      break;

   case 8:  // PgUp, PgDn, Done
	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_PREV,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 5, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "PgUp",
	      BTN_TXTOFFSET, 8, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
	   lcd_ButtonDef( BTN_NEXT,
	      BTN_TEXT, "PgDn",
	      BTN_END );
	   lcd_ButtonDef( BTN_CANCEL,
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
	      BTN_TEXT, "Exit",
	      BTN_END );

   	break;
   case 9:

      lcd_ShowKeypad(1);

	   // Draw bottom buttons
	   lcd_Font("16B");
	   lcd_ButtonDef( BTN_NEXT,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 5, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_TEXT, "Next",
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_TXTOFFSET, 8, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
	   lcd_ButtonDef( BTN_CANCEL,
	      BTN_MOM,                      // momentary operation
	      BTN_TLXY, 257, 205,             // starting x,y for buttons
		   BTN_TYPE, BUTTON_RELEASE,
	      BTN_MARGINS, 5, 330,         // set left and right margins
	      BTN_SEP, 63, 43,              // set up for button sep
	      BTN_TEXT, "Exit",
	      BTN_TXTOFFSET, 15, 9,
	      BTN_BMP, BMP_med_button, BMP_med_button_dn,
	      BTN_END );
      break;
   }

}

void lcd_displayMsgs(char * msgNum)
{  // show traditional lcd messages on the color touch screen
   //char pw; // pen width
   //pw=3;
   lcd_Font("16x32i");

   //lcd_Rectangle(5+pw, 5+pw, 315-pw, 80-pw, 1);	 	// inside paint
   //lcd_Rectangle(5+pw, 85+pw, 315-pw, 160-pw, 1);	// inside paint
   // check for showing alarm message in red
	if (msgNum[0] == MSG_ALARM) lcd_BFcolorsB(lcd_WHITE, lcd_RED);
   else lcd_BFcolorsB(lcd_BLACK, lcd_WHITE); // inside color
   lcd_DispText(sys_message[msgNum[0]].msg, 30, 12, MODE_NORMAL);
   lcd_DispText(sys_message[msgNum[1]].msg, 30, 42, MODE_NORMAL);
   // check for showing alarm message in red
	if (msgNum[2] == MSG_ALARM) lcd_BFcolorsB(lcd_WHITE, lcd_RED);
   else lcd_BFcolorsB(lcd_BLACK, lcd_WHITE); // inside color
   lcd_DispText(sys_message[msgNum[2]].msg, 30, 90, MODE_NORMAL);
   lcd_DispText(sys_message[msgNum[3]].msg, 30, 120, MODE_NORMAL);
}
void lcd_printMessage(char line, char * msg)
{  // show traditional lcd messages on the color touch screen
   //char pw; // pen width
   //pw=3;
   int y;
   y=0;
   lcd_Font("16x32i");

   switch (line)
   {
   case 0: y=12; break;
   case 1: y=42; break;
   case 2: y=90; break;
   case 3: y=120; break;
   }
   if (y>0)
   {
	   lcd_BFcolorsB(lcd_BLACK, lcd_WHITE); // inside color
   	lcd_DispText(msg, 30, y, MODE_NORMAL);
   }
}
void lcd_processTouchScreen(int button)
{  // buttons from the main display
   // optionally process button passed as parameter
   // if button = -2 then check for a new button press
	//int button;
   if (button==-2) button = lcd_GetTouch(1);
   // reset screen saver if a button is pressed
   if (button != -1) lcd_screenSaver(LCD_BRIGHT);

   switch (button)
   {
   case BTN_MENU:
	   if (system_state==MALFUNCTION_STATE) lcd_enterSetupMode(0);
      // checking for IDLE is redundant since buttons are removed during a transaction
      else if (system_state==IDLE_STATE) lcd_enterSetupMode(1);
	   lcd_drawScreen(1, lcd_WITH_BUTTONS);		// redraw main screen
   	break;
   case BTN_DIRECTORY:
      lcd_showDirectory(0);
	   lcd_drawScreen(1, lcd_WITH_BUTTONS);		// redraw main screen
      break;
   case BTN_HELP:
      lcd_helpScreen(0); // help->about
      lcd_drawScreen(1, lcd_WITH_BUTTONS);		// redraw main screen
      break;
   case BTN_STAT+256:  // Stat on
   	btnStatFlag=1;
   	break;
   case BTN_STAT:     // Stat off
   	btnStatFlag=2;
      break;
   case BTN_CRETURN:
      lcd_showDirectory(1);
	   lcd_drawScreen(1, lcd_WITH_BUTTONS);		// redraw main screen
   	break;
   }

}
char lcd_stationButton;  // for holding send-to requests
char lcd_returnCarrierButton; // for holding returnCarrier requests
void lcd_showDirectory(char mode)
{  // show list of all active stations
   // mode 0 = standard directory
   //      1 = carrier-return directory
	char i;
   int button;
   int xpos, ypos, dy;
   char buf[4];
   buf[0]=0; buf[1]=0; // for station number text

   if (mode==0) lcd_drawScreen(5, "STATION DIRECTORY");
   else         lcd_drawScreen(5, "RETURN CARRIER FROM");

   lcd_Font("16B");
   xpos=10; // initial x,y button position
   ypos=50;
   dy=39;
   for (i=0; i<LAST_STATION; i++)
   {  if ((1<<i) & STATION_SET)
   	{  buf[0]='1'+i;
	      // show a button with the station number
	      lcd_ButtonDef( i+1, BTN_MOM,       // momentary operation
	         BTN_TLXY, xpos, ypos,           // starting x,y for buttons
	         BTN_MARGINS, 5, 200,          // set left and right margins
	         BTN_TYPE, BUTTON_RELEASE,
	         BTN_TEXT, buf,
	         BTN_TXTOFFSET, 12, 9,
	         BTN_BMP, BMP_button_up, BMP_button_dn,
	         BTN_END );
         if (remote_data[REMOTE_CIC] & (1<<i)) lcd_BFcolorsB(lcd_BLACK, lcd_GREEN);
         else lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      	lcd_DispText(param.station_name[i+1].name, xpos+40, ypos, MODE_NORMAL);
         lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
         lcd_DispText(param.phoneNum[i+1], xpos+40, ypos+18, MODE_NORMAL);
         if (xpos==10) xpos=165;
         else        { xpos=10; ypos+=dy; }
      }
   }
   // What about slave station
   if (slaveAvailable)
   {  // show a button with the station number
   	buf[0]='0'+SLAVE;
      lcd_ButtonDef( SLAVE, BTN_MOM,       // momentary operation
         BTN_TLXY, xpos, ypos,           // starting x,y for buttons
         BTN_TEXT, buf,
         BTN_END );
      if (slave_cic) lcd_BFcolorsB(lcd_BLACK, lcd_GREEN);
      else lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      lcd_DispText(param.station_name[i+1].name, xpos+40, ypos, MODE_NORMAL);
      lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      lcd_DispText(param.phoneNum[i+1], xpos+40, ypos+18, MODE_NORMAL);
   }
     // What about main station at the slave
   else if (param.slaveController)
   {  // show a button with the station number
   	buf[0]=param.station_name[0].name[0]; // take first character of name //='0';
      lcd_ButtonDef( SLAVE, BTN_MOM,       // momentary operation
         BTN_TLXY, xpos, ypos,           // starting x,y for buttons
         BTN_TEXT, buf,
         BTN_END );
      lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      lcd_DispText(param.station_name[0].name, xpos+40, ypos, MODE_NORMAL);
      lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      lcd_DispText(param.phoneNum[0], xpos+40, ypos+18, MODE_NORMAL);
   }

   // show legend at bottom for CIC
   lcd_BFcolorsB(lcd_BLACK, lcd_GREEN);
   lcd_DispText("Green", 5, 220, MODE_NORMAL);
   lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
   lcd_DispText(" = Carrier In Chamber", 0, 0, MODE_NORMAL);


   // now show numbers for admin and maintenance
   //lcd_DispText("Administrator:", 10, 200, MODE_NORMAL);
   //lcd_DispText(param.phoneNum[ADMIN_PHONE], 110, 200, MODE_NORMAL);
   //lcd_DispText("Maintenance:",  10, 218, MODE_NORMAL);
   //lcd_DispText(param.phoneNum[MAINT_PHONE], 110, 218, MODE_NORMAL);

   // Show stat and carrier return
/*   lcd_ButtonDef( 21, BTN_LAT,
      BTN_TLXY, xpos, ypos,         // starting x,y for buttons
      BTN_TYPE, BUTTON_LAT_0,
      BTN_TEXT, buf,
      BTN_TXTOFFSET, 12, 9,
      BTN_BMP, BMP_button_up, BMP_button_dn,
      BTN_END );
*/

   // Wait for a button
   menu_timeout = SEC_TIMER + 60;
   while(((button=lcd_GetTouch(100)) == -1) && !secTimeout(menu_timeout) ) maintenance();
   // treat button as a send-to request or return-from request
   if ((button >= 0) && (button <= SLAVE)) lcd_stationButton = button;
   if (mode==1) lcd_returnCarrierButton=TRUE;  // is this a return carrier request?

}
char lcd_returnCarrier(void)
{  // returns the lcd_returnCarrierButton
	char rtnVal;
   #GLOBAL_INIT
   { lcd_returnCarrierButton=0; }

   rtnVal = lcd_returnCarrierButton;
   lcd_returnCarrierButton=0; // reset whenever it is accesses
	return rtnVal;
}
char lcd_sendTo(void)
{  // returns the lcd_stationButton
	char rtnVal;
   #GLOBAL_INIT
   { lcd_stationButton=0; }

   rtnVal = lcd_stationButton;
   lcd_stationButton=0; // reset whenever it is accesses
	return rtnVal;
}
int lcd_Center(char * string, char font)
{
	int temp;

   if (font==1)      temp = 160 - (int)(strlen(string) * 7);  // "24"
   else if (font==2) temp = 160 - (int)(strlen(string) * 4);  // "16"
   if (temp < 5) temp = 5;
	return temp;
}
void lcd_enterSetupMode(char operatorLevel)
{
	int button;
   char mych;
   char keepLooping;
   char menu_idx;
   char page;
   char anotherPage;
   char showPage;
   char newLevel;
   char changed;
   keepLooping=TRUE;
   page=0;
   changed=FALSE; // None yet

   // clear the button input buffer
   lcd_GetTouch(1);

	anotherPage = lcd_ShowMenu(operatorLevel, page);
   // Initialize 60 second menu timeout
   menu_timeout = SEC_TIMER + 60;

   while ( (keepLooping) && !secTimeout(menu_timeout) )
   {
      maintenance();  // watchdog, led activity, UDP commands
      // inKey = getKey();
      showPage=FALSE;
      button = lcd_GetTouch(100);
      if (button != -1)
      {  // valid button pressed
      	menu_timeout = SEC_TIMER + 60;
	      if ((button >= BTN_MNU_FIRST) && (button <= BTN_MNU_FIRST+MNU_LAST))
	      {  menu_idx = button-BTN_MNU_FIRST;
         	newLevel = operatorLevel;
	         changed |= lcd_ProcessMenuItem(menu_idx, &newLevel);
            // Did we advance to a new menu
            if (newLevel != operatorLevel)
            { operatorLevel = newLevel;
              page=0;
            }
            // continue to show menu?
            if (operatorLevel==99) keepLooping=FALSE;
            // update display of menu items?
            if (!secTimeout(menu_timeout)) showPage=TRUE;
	      }
	      else if (button == BTN_PREV)
	      {  if (page>0) { page--; showPage=TRUE;}
	      }
	      else if (button == BTN_NEXT)
	      {  if (anotherPage) { page++; showPage=TRUE;}
	      }
	      //else if (button == BTN_SAVE)
	      else if (button == BTN_CANCEL)  // DONE
         {
         	if (changed)
            {  // save changes if needed
	            lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	            lcd_ClearScreen ();
	            lcd_Origin( 0, 0 );
	            lcd_Font("24");
	            lcd_DispText("SAVING CHANGES ...", 10, 50, MODE_NORMAL);
	            if (writeParameterSettings() == 0)
	               lcd_DispText("\nCHANGES SAVED", 0, 0, MODE_NORMAL);
	            else
	               lcd_DispText("\nERROR SAVING CHANGES", 0, 0, MODE_NORMAL);

	            msDelay(500);
            }
         	keepLooping = FALSE;
         }
	      //else if (button == BTN_CANCEL) keepLooping = FALSE;

         // show the same or next menu page if needed
         if (showPage && keepLooping) anotherPage = lcd_ShowMenu(operatorLevel, page);
      }

	}

}


void lcd_ShowTransactionProgress(char source, char dest, char direction, int progress, unsigned long transTimer)
{	// call this routine to update the display with transaction progress
	// source, dest are system station numbers 0-8
   // direction is DIR_SEND (left to right) or DIR_RETURN (right to left)
   // progress is % of progress into transaction
   // transStartTime is time into transaction so far in seconds

	static char lastSource;
   static char lastDest;
   static char lastDirection;
   static char lastProgress;  // as percentage 0-100
   //static char last_CIC;
   static unsigned long lastTransTimer;
   static int x1, x2, y1, y2;
   int xmid;
   static char pw;  				// pen width

   #GLOBAL_INIT
   {	// initialize local variables
   	lastSource=0;
      lastDest=0;
      lastDirection=0;
      lastProgress=0;
      lastTransTimer=0;
      x1=6; x2=314;
      y1=176; y2=199;
      pw=1;
   }

   // show source station name
   if (source != lastSource)
   {
   	lastSource=source;
   }

   // show destination station name
   if (dest != lastDest)
   {
   	lastDest=dest;
   }

   // show state progress
   if ((progress != lastProgress)) // || (di_carrierInChamber != last_CIC))
   {
	   // draw a box using background
   	// draw a boarder box
      lcd_PenWidth(pw);

      // last_CIC=di_carrierInChamber;  // always remember last
      if (progress <= 100)
      {  // any other progress just blank it out
	      lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);   // border color
         lcd_Rectangle(12, 163, 150, 203, 1);  // blank out CIC
	      lcd_BFcolorsB( lcd_BLUE, lcd_WHITE);   // border color
	      lcd_Rectangle(x1-pw, y1-pw, x2+pw, y2+pw, 0);
	      // fill box with specific progress and remainder
         lcd_Font("18BC");
	      if (direction == DIR_SEND)
	      {  // progress left to right
	         xmid = x1 + (int)((x2-x1) * (long)progress/100);
	         lcd_Rectangle(x1, y1, xmid, y2, 1);    // fill left side progress
	         lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);  // unfill color
	         lcd_Rectangle(xmid, y1, x2, y2, 1);    // fill right side remaining
		      lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
				lcd_DispText("-->>", 150, y1+pw, MODE_TRANS); // show direction arrow
	      } else
	      {  // progress right to left
	         xmid = x2 - (int)((x2-x1) * (long)progress/100);
	         lcd_Rectangle(xmid, y1, x2, y2, 1);    // fill right side progress
	         lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);  // unfill color
	         lcd_Rectangle(x1, y1, xmid, y2, 1);    // fill left side remaining
		      lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
            lcd_DispText("<<--", 150, y1+pw, MODE_TRANS); // show direction arrow
	      }
         // show the station names; NOTE: source is really main station and dest is remote station
         lcd_DispText(param.station_name[source].name, 10, y1+pw, MODE_TRANS);
         xmid = 305 - 11*strlen(param.station_name[dest].name);
         lcd_DispText(param.station_name[dest].name, xmid, y1+pw, MODE_TRANS);
      }
      else if (progress == 999)
      {  // blank out when progress = 999
	      lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);   // border color
	      lcd_Rectangle(x1-pw, y1-pw, x2+pw, y2+pw, 1);
      } else
      {  // otherwise handle CIC
         lcd_showCIC(0);
      }
      lastProgress=progress;
   } else
   {  if (progress >= 100) lcd_showCIC(0);  // only if no progress bar showing
   }

   // show transaction timer
   if (transTimer != lastTransTimer)
   {
   	lastTransTimer=transTimer;
   }

}
void lcd_showCIC(char forceit)
{  // show CIC on screen
   static char last_CIC;
   if ((di_carrierInChamber != last_CIC) || forceit)
   {
      last_CIC=di_carrierInChamber;  // always remember last
	   if (last_CIC)
	   {  // show CIC bright
	      lcd_DispBitmap( BMP_green_light, 255, 170);
	      lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	   } else
	   {  // show CIC dim
	      lcd_DispBitmap( BMP_ltgrey_light, 255, 170);
	      lcd_BFcolorsB( lcd_LGREY, lcd_WHITE);
      }
	   lcd_Font("16B");
	   lcd_DispText("CIC", 262, 215, MODE_NORMAL);
	   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);

   }
}
void lcd_ShowKeypad(char opts)
{  // display 0..9 in a keypad arrangement on the screen
   // opts = 0 = no '-' button
   //        1 = use '-' button
	char i;
   char btn[2];

   i=1; // first digit 1
   btn[0]=49;
   btn[1]=0;

   // draw first button
   lcd_Font("16B");
   lcd_ButtonDef( '0'+i,
      BTN_MOM,                      // momentary operation
      BTN_TLXY, 200, 55,               // starting x,y for buttons
      BTN_TYPE, BUTTON_RELEASE,
      BTN_MARGINS, 200, 300,        // set left and right margins
      BTN_SEP, 35, 35,              // set up for button sep
      BTN_TEXT, btn,
      BTN_TXTOFFSET, 11, 9,
      BTN_BMP, BMP_button_up, BMP_button_dn,
      BTN_END );
   // draw 2-9
   for (i=2; i<10; i++)
   {  btn[0]++;
	   lcd_ButtonDef( '0'+i,
	      BTN_TEXT, btn,
	      BTN_END );
	}
   // draw last buttons
   if (opts==1) // use '-' button
   {  i='-';
      btn[0]='-';
	   lcd_ButtonDef( i,
	      BTN_TEXT, btn,
	      BTN_END );
   }
   // draw '0'
   i=0;
   btn[0]=48;
   lcd_ButtonDef( '0'+i,
      BTN_TEXT, btn,
      BTN_END );
   // draw 'Del'
   lcd_ButtonDef( BTN_DEL,
      BTN_TXTOFFSET, 5, 9,
   	BTN_TEXT, "Del",
      BTN_END );

}
char lcd_SelectChoice(char *choice, char *label, char *optZero, char *optOne)
{
	// Show label and two choices and allow selection
   // choice is modified as TRUE (optZero) or FALSE (optOne) based on selection
   // function returns 0 if cancel or 1 if a choice is made

   int button;

	lcd_drawScreen(3, "MENU");
   lcd_Font("24");
   lcd_DispText(label, lcd_Center(label, 1), 50, MODE_NORMAL);
   lcd_DispText(optZero, 150, 85, MODE_NORMAL);
   lcd_DispText(optOne, 150, 115, MODE_NORMAL);

   // show optZero choice
   lcd_ButtonDef( BTN_YES_ON,
   BTN_LAT,                      // latching operation
   BTN_TLXY, 110, 80,             // starting x,y for buttons
   BTN_TYPE, *choice ? BUTTON_LAT_1 : BUTTON_LAT_0,
   BTN_BMP, BMP_check_box, BMP_check_box_click,
   BTN_END );
   // show optOne choice
   lcd_ButtonDef( BTN_NO_OFF,
   BTN_TLXY, 110, 110,             // starting x,y for buttons
   BTN_TYPE, *choice ? BUTTON_LAT_0 : BUTTON_LAT_1,
   BTN_BMP, BMP_check_box, BMP_check_box_click,
   BTN_END );
   // show Cancel button
   lcd_Font("16B");
   lcd_ButtonDef( BTN_CANCEL,
      BTN_MOM,                      // momentary operation
      BTN_TLXY, 257, 205,             // starting x,y for buttons
      BTN_TYPE, BUTTON_RELEASE,
      BTN_TEXT, "Cancel",
      BTN_TXTOFFSET, 5, 9,
      BTN_BMP, BMP_med_button, BMP_med_button_dn,
      BTN_END );

   // wait for button press & release
   menu_timeout = SEC_TIMER + 60;
	while( ((button = lcd_GetTouch(100)) == -1) && !secTimeout(menu_timeout) )
   	maintenance();

   // handle selection
   if (button == 256+BTN_NO_OFF)
   {  // update screen
      *choice=FALSE;
   }
   else if (button == 256+BTN_YES_ON)
   {  // update screen
      *choice=TRUE;
   }
	if ((button == BTN_CANCEL) || (button == -1)) return 0; // cancel or timeout
   else
   {  // update scren to show choice
	   lcd_ButtonDef( BTN_YES_ON,
	   BTN_LAT,                      // latching operation
	   BTN_TLXY, 110, 80,             // starting x,y for buttons
	   BTN_TYPE, *choice ? BUTTON_LAT_1 : BUTTON_LAT_0,
	   BTN_BMP, BMP_check_box, BMP_check_box_click,
	   BTN_END );
	   // show optZero choice
	   lcd_ButtonDef( BTN_NO_OFF,
	   BTN_TLXY, 110, 110,             // starting x,y for buttons
	   BTN_TYPE, *choice ? BUTTON_LAT_0 : BUTTON_LAT_1,
	   BTN_BMP, BMP_check_box, BMP_check_box_click,
	   BTN_END );
	   msDelay(500); // wait so you can see the choice
   	return 1;  // got a choice
   }
}
char lcd_GetNumberEntry(char *description, unsigned long * par_value,
         unsigned long par_min, unsigned long par_max, char * par_units, char max_digits)
{  // Allows numeric keypad entry using the touch screen
   // return value is 0 = no change or cancel or timeout
   //                 1 = valid number entered and updated to par_value

	int button;
   char keepLooping;
   unsigned long inval;
   char number[8];  // for display of numeric text
   char numDigits;
   char rtnval;
   char i;
   inval=0;
   keepLooping=TRUE;
   numDigits=0;
   rtnval=0;  // assume no good

   // Initialize 60 second menu timeout
   menu_timeout = SEC_TIMER + 60;

   // draw screen with keypad
   lcd_drawScreen(4, "ENTER VALUE");

   // print title and place to print the number
   lcd_Font("18BC");
   lcd_DispText(description, 20, 50, MODE_NORMAL);
	lcd_DispBitmap( BMP_input_box, 45, 80 );
   lcd_DispText(par_units, 132, 88, MODE_NORMAL);

   // show actual, min and max
   lcd_Font("16B");
   lcd_DispText("Min = ", 50, 120, MODE_NORMAL);
   lcd_DispText(ltoa((long)par_min, number), 0, 0, MODE_NORMAL);
   lcd_DispText("Current = ", 50, 140, MODE_NORMAL);
   lcd_DispText(ltoa((long)*par_value, number), 0, 0, MODE_NORMAL);
   lcd_DispText("Max = ", 50, 160, MODE_NORMAL);
   lcd_DispText(ltoa((long)par_max, number), 0, 0, MODE_NORMAL);
   // Setup for first character to display
	number[0]=0; number[1]=0;

   while ( (keepLooping) && !secTimeout(menu_timeout) )
   {
      maintenance();  // watchdog, led activity, UDP commands
      button = lcd_GetTouch(100);
      if (button != -1)
      {  // valid button pressed
      	menu_timeout = SEC_TIMER + 60;
	      if ((button >= '0') && (button <= '9') && (numDigits < max_digits))
         {  // add the digit to the string
         	number[numDigits]=button;
         	numDigits++;
         	number[numDigits]=0;  // trailing null
				lcd_DispText(number, 50, 87, MODE_TRANS); // show the number
	      } else if ((button == BTN_DEL) && (numDigits > 0))
         {  numDigits--;
         	number[numDigits]=0;  // trailing null
            // reprint the screen
	         lcd_DispBitmap( BMP_input_box, 45, 80 );
	         lcd_DispText(number, 50, 87, MODE_TRANS); // show the number
	      } else if (button == BTN_CANCEL)
	      {  keepLooping=FALSE;
	      } else if (button == BTN_OK)
	      {  inval = (unsigned long)atol(number);
         	if ((inval >= par_min) && (inval <= par_max))
         	{  keepLooping=FALSE;
	         	*par_value = inval;
               rtnval=1;
            } else
            { lcd_DispText("OUTSIDE RANGE", 50, 180, MODE_REV);
              msDelay(750);
              numDigits=0;
				  number[0]=0; number[1]=0;
				  lcd_DispBitmap( BMP_input_box, 45, 80 );
				  lcd_DispText(number, 50, 87, MODE_TRANS); // show the number
            }
         }
      }
   }
   return rtnval;
}
void lcd_setClock()
{
	int button;
   char keepLooping;
   struct tm time;
   unsigned long timedate;

   timedate=SEC_TIMER;
   mktm(&time, timedate);

   setTimeMessages(MSG_DATE_TIME, timedate);
	lcd_drawScreen(7, "SET DATE & TIME");

   keepLooping=TRUE;
   menu_timeout = SEC_TIMER + 60;
   while ( (keepLooping) && !secTimeout(menu_timeout) )
   {
      maintenance();  // watchdog, led activity, UDP commands
      button = lcd_GetTouch(100);
      if (button != -1)
      {  // valid button pressed
      	menu_timeout = SEC_TIMER + 60;
         switch( button )
         {
         case BTN_SAVE:  // Done
            keepLooping=FALSE;
            break;
			case 0: // +month
            if (time.tm_mon<12) time.tm_mon++;
            break;
         case 1: // -month
         	if (time.tm_mon>1) time.tm_mon--;
            break;
         case 2: // +day
         	if (time.tm_mday<31) time.tm_mday++;
            break;
         case 3: // -day
         	if (time.tm_mday>1) time.tm_mday--;
            break;
			case 4: // +year
         	if (time.tm_year<140) time.tm_year++;
            break;
         case 5: // -year
         	if (time.tm_year>100) time.tm_year--;
            break;
         case 6: // +hour
         	if (time.tm_hour<23) time.tm_hour++;
            break;
         case 7: // -hour
         	if (time.tm_hour>0) time.tm_hour--;
            break;
         case 8: // +minute
         	if (time.tm_min<59) time.tm_min++;
            break;
         case 9: // -minute
         	if (time.tm_min>0) time.tm_min--;
         	break;
         }
	      // update and print date/time message
	      lcd_Font("16x32i");
		   timedate = mktime(&time);
		   setTimeMessages(MSG_DATE_TIME, timedate);
	      lcd_DispText(sys_message[MSG_DATE_TIME].msg, 30, 60, MODE_NORMAL);
      }
   }
	// put time back into timer and real-time-clock
   //write_rtc(timedate);
	if (!secTimeout(menu_timeout))
   {  // update only if not exiting due to timeout
	   tm_wr(&time);
	   SEC_TIMER = timedate;
	   menu_timeout = SEC_TIMER + 60;
	}
}
char lcd_defineActiveStations()
{  // define the active stations
   // returns TRUE if activestations were changed
   char rtsIn;
   char done;
   char j, col, msgbuf[17];
   char original;
   char inKey;
   char inputStations;
   int button;

	lcd_drawScreen(5, "DEFINE ACTIVE STATIONS");
	lcd_DispText("PRESS ACTIVE SEND BUTTONS", 60, 50, MODE_NORMAL);
   lcd_Font("12x24");
   strcpy(msgbuf, sys_message[MSG_BLANK].msg);  // buffer to show stations

   original = STATION_SET;  // save for later
   STATION_SET = 0xFF;      // to allow requestToSend to return any pushbutton
   inputStations = 0;      // reset
   if (param.headDiverter==TRUE) inputStations |= 0x80;

   done=FALSE;
   // Loop until done or timeout
	while ((done==FALSE) && !secTimeout(menu_timeout))
   {
		maintenance();  // watchdog, led activity, UDP commands
	   button = lcd_GetTouch(100);

	   // If BTN_SAVE, save changes
	   if (button == BTN_EXIT)  // Exit button
	   {
         STATION_SET = inputStations;
         done=TRUE;
      }
      // If station button, include bit and show on display
      rtsIn = firstBit(di_requestToSend);
      if (rtsIn)
      {  inputStations |= station2bit(rtsIn);
         col = (rtsIn * 2) -1;
         msgbuf[col] = 48 + rtsIn;
         //lcd_print(SYSTEMLCD, 1, msgbuf);
			lcd_DispText(msgbuf, 55, 80, MODE_NORMAL);
	      menu_timeout = SEC_TIMER + 60;  // reset menu timeout
      }
   }
   param.activeStations = STATION_SET;
   if (STATION_SET == original) return FALSE;
   else return TRUE;
}
char lcd_editStationNames()
{  // Returns TRUE if names changed
   char pos, j, changed, row, col, msgbuf[17];
   char keepLooping;
   int button;
   char inKey;
   struct iomessage message;  // in order to transmit to slave
   row=0;
   changed=0;

	lcd_drawScreen(6, "EDIT STATION NAMES");
   lcd_Font("12x24");

   while ((row <= SYSTEM_NAME) && !secTimeout(menu_timeout))  // row < number of names (0..SYSTEM_NAME)
   {
      // display this station name
      //strcpy(msgbuf, param.station_name[row].name);
      //strncat(msgbuf, "                ", 16-strlen(msgbuf));
      strcpy(msgbuf, "___________");  // fill with underscores
      //msgbuf[15]=0x30+row;  // display number
		lcd_DispText(msgbuf, 20, 50, MODE_NORMAL); // show the name
      lcd_DispText(param.station_name[row].name, 20, 50, MODE_NORMAL);  // show existing name
	   lcd_Font("16B");
      lcd_DispText("(", 180, 55, MODE_NORMAL); // show the default name
		lcd_DispText(defaultStaName[row], 0, 0, MODE_NORMAL); // show the default name
		lcd_DispText(")           ", 0, 0, MODE_NORMAL); // blank out leftovers
	   lcd_Font("12x24");
      col=0;
      keepLooping=TRUE;
	   while ( (keepLooping) && !secTimeout(menu_timeout) )
	   {
	      maintenance();  // watchdog, led activity, UDP commands
	      button = lcd_GetTouch(100);
	      if (button != -1)
	      {  // valid button pressed
	         menu_timeout = SEC_TIMER + 60;
	         switch( button )
	         {
            case BTN_NEXT:  // next message
               // row++; loop will increment row
               keepLooping=FALSE;
               break;
            case BTN_CANCEL:  // finish
               keepLooping=FALSE;
               // row=99;
               break;
            case 8:  // backspace
               if (col>0)
               {  if (col<11) msgbuf[col]='_';
               	col--;
               	msgbuf[col]='_';
                  lcd_DispText(msgbuf, 20, 50, MODE_NORMAL); // show the name
               }
               break;
            default:  // ascii key
               if (col<11)
               {  msgbuf[col]=button;
                  col++;
                  //msgbuf[col]='_';
               	lcd_DispText(msgbuf, 20, 50, MODE_NORMAL); // show the name
		            changed=TRUE;
               }
               break;
            }
         }
      }
      // replace _ with space

      // trim spaces
      j=10;
      while (j>0)
      {  // replace _ with null
         if (msgbuf[j]=='_') msgbuf[j]=0;
      	// trim spaces
      	if (msgbuf[j]>32)  // first non-space
         { 	msgbuf[j+1]=0;
         	j=0;
         } else --j;
      }

      // put name back into main storage
      if (msgbuf[0]!='_') strcpy(param.station_name[row].name, msgbuf);

      // send name to remote station controller
      message.devAddr=ALL_DEVICES;
      message.command=SET_STATION_NAME;
      message.station=row;
      for (j=0; j<3; j++)
      {
	      pos=j*4;
	      message.data[0] = pos;
	      message.data[1] = param.station_name[row].name[pos];
	      message.data[2] = param.station_name[row].name[pos+1];
	      message.data[3] = param.station_name[row].name[pos+2];
	      message.data[4] = param.station_name[row].name[pos+3];

			// send this chunk
	      msDelay(10); send_command(message);
      }
      if (button==BTN_CANCEL) row=99;
      else row++;  // next item
   }

   if (changed)
   {  // tell slave to finalize update
      message.devAddr=ALL_DEVICES;
      message.command=SET_STATION_NAME;
      message.station=69;  // save to eeprom
      msDelay(10); send_command(message);
   }

   // rebuild station name messages
   buildStationNames();

   return changed;
}
char lcd_editPhoneNums()
{  // Returns TRUE if phone numbers changed
   char pos, j, changed, row, col, msgbuf[10];
   char keepLooping;
   char label[20];
   int button;
   struct iomessage message;  // in order to transmit to slave
   row=0;
   changed=0;

	lcd_drawScreen(9, "SET PHONE NUMBERS");
   lcd_Font("12x24");

   while ((row <= 10) && !secTimeout(menu_timeout))  // row < number of names (0..SYSTEM_NAME)
   {
      // display this station phone number and details
      strcpy(msgbuf, "        ");  // fill with spaces
	   lcd_Font("18BC");
      lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      sprintf(label, "Phone # %d ", row);
      lcd_DispText(label, 50, 50, MODE_NORMAL);
	   lcd_DispBitmap( BMP_input_box, 45, 80 );
	   lcd_Font("8x16");
      // white out previous station name and number
      lcd_BFcolorsB(lcd_WHITE, lcd_WHITE);
      lcd_Rectangle(50, 115, 130, 155, 1);
      // show editable number, station name and existing number
      lcd_BFcolorsB(lcd_BLACK, lcd_LGREY);
		lcd_DispText(msgbuf, 54, 87, MODE_NORMAL);
      lcd_DispText("\n\n", 0, 0, MODE_NORMAL);
      lcd_BFcolorsB(lcd_BLACK, lcd_WHITE);
      // show station name or admin or maint
		if (row<=8) lcd_DispText(param.station_name[row].name, 0, 0, MODE_NORMAL); // show the station name
      else if (row == ADMIN_PHONE) lcd_DispText("Administrator", 0, 0, MODE_NORMAL);
      else lcd_DispText("Maintenance  ", 0, 0, MODE_NORMAL);
      lcd_DispText("\n", 0, 0, MODE_NORMAL);
      lcd_DispText(param.phoneNum[row], 0, 0, MODE_NORMAL);
      lcd_BFcolorsB(lcd_BLACK, lcd_LGREY);
	   //lcd_Font("12x24");
      col=0;
      keepLooping=TRUE;
	   while ( (keepLooping) && !secTimeout(menu_timeout) )
	   {
	      maintenance();  // watchdog, led activity, UDP commands
	      button = lcd_GetTouch(100);
	      if (button != -1)
	      {  // valid button pressed
	         menu_timeout = SEC_TIMER + 60;
	         switch( button )
	         {
            case BTN_NEXT:  // next message
               keepLooping=FALSE;
               break;
            case BTN_CANCEL:  // finish
               keepLooping=FALSE;
               break;
            case BTN_DEL:  // backspace
               if (col>0)
               {  if (col<8) msgbuf[col]=' ';
               	col--;
               	msgbuf[col]=' ';
                  lcd_DispText(msgbuf, 54, 87, MODE_NORMAL); // show the name
               }
               break;
            default:  // ascii key
					//if ((button >= 0) && (button <= 9)) button += '0';
               if (col<8)
               {  msgbuf[col]=button;
                  col++;
               	lcd_DispText(msgbuf, 54, 87, MODE_NORMAL); // show the name
		            changed=TRUE;
               }
               break;
            }
         }
      }
      // trim spaces
      j=8;
      while (j>0)
      {  // replace _ with null
         if (msgbuf[j]=='_') msgbuf[j]=0;  // doesn't apply anymore but leave incase it comes back
      	// trim spaces
      	if (msgbuf[j]>32)  // first non-space
         { 	msgbuf[j+1]=0;
         	j=0;
         } else --j;
      }

      // put name back into main storage
      if (msgbuf[0]!='_') strcpy(param.phoneNum[row], msgbuf);

      // send name to remote station controller
      message.devAddr=ALL_DEVICES;
      message.command=SET_PHONE_NUMS;
      message.station=row;
      for (j=0; j<2; j++)
      {
	      pos=j*4;
	      message.data[0] = pos;
	      message.data[1] = param.phoneNum[row][pos];
	      message.data[2] = param.phoneNum[row][pos+1];
	      message.data[3] = param.phoneNum[row][pos+2];
	      message.data[4] = param.phoneNum[row][pos+3];

			// send this chunk
	      msDelay(10); send_command(message);
      }

      if (button==BTN_CANCEL) row=99;  // all done
      else row++;  // next item
   }

   if (changed)
   {  // tell slave to finalize update
      message.devAddr=ALL_DEVICES;
      message.command=SET_PHONE_NUMS;
      message.station=69;  // save to eeprom
      msDelay(10); send_command(message);
   }

   return changed;
}
char lcd_enableAdvancedFeatures(char menu_level, char * description)
{  // get password for the requested level
	char reqdPW[5];
   char enteredPW[5];
   char rtnVal;

   // determine which password to compare with
   switch (menu_level)
   {
   case 2: 	strcpy(reqdPW, param.adminPassword); break;
   case 3: 	strcpy(reqdPW, param.maintPassword); break;
   case 4: 	strcpy(reqdPW, param.cfgPassword); break;
   default: reqdPW[0]=0;
   }

	rtnVal=FALSE;  // assume no good
   if (strlen(reqdPW)==0) rtnVal=TRUE;
   else
   {  // get the password/pin
   	if (lcd_getPin(enteredPW, description))
      {
      	if (strcmp(enteredPW, reqdPW)==0) rtnVal=TRUE;
         else
         {  // sorry charlie
				lcd_BFcolorsB( lcd_WHITE, lcd_RED);
			   lcd_Font("24");
			   lcd_DispText(" INCORRECT PIN ", 17, 160, MODE_NORMAL);
            msDelay(2000);
         }
      }
   }
   return rtnVal;
}
char lcd_getPin(char *PIN, char *description)
{  // get a 4 digit pin from the touch screen
	int button;
   char keepLooping;
   char number[5];  // for storing entered digits
   char asteric[5]; // for display on screen
   char numDigits, maxDigits;
   char rtnval;
   char i;
   keepLooping=TRUE;
   numDigits=0;
   maxDigits=4;
   rtnval=0;  // assume no good

   // Initialize 60 second menu timeout
   menu_timeout = SEC_TIMER + 60;

   // draw screen with keypad
   lcd_drawScreen(4, description);

   // print title and place to print the number
   lcd_Font("18BC");
   lcd_DispText("ENTER 4 DIGIT PIN", 20, 50, MODE_NORMAL);
	lcd_DispBitmap( BMP_input_box, 45, 80 );

   // show actual, min and max
   lcd_Font("32B");
   // Setup for first character to display
	number[0]=0; number[1]=0;
   asteric[0]=0; asteric[1]=0;

   while ( (keepLooping) && !secTimeout(menu_timeout) )
   {
      maintenance();  // watchdog, led activity, UDP commands
      button = lcd_GetTouch(100);
      if (button != -1)
      {  // valid button pressed
      	menu_timeout = SEC_TIMER + 60;
	      if ((button >= '0') && (button <= '9') && (numDigits < maxDigits))
         {  // add the digit to the string
         	number[numDigits]=button;
            asteric[numDigits]='*';
         	numDigits++;
         	number[numDigits]=0;  // trailing null
            asteric[numDigits]=0;
				lcd_DispText(asteric, 50, 87, MODE_TRANS); // show the number
	      } else if ((button == BTN_DEL) && (numDigits > 0))
         {  numDigits--;
         	number[numDigits]=0;  // trailing null
            asteric[numDigits]=0;
            // reprint the screen
	         lcd_DispBitmap( BMP_input_box, 45, 80 );
	         lcd_DispText(asteric, 50, 87, MODE_TRANS); // show the number
	      } else if (button == BTN_CANCEL)
	      {  keepLooping=FALSE;
	      } else if (button == BTN_OK)
	      {  strcpy(PIN, number);
         	keepLooping=FALSE;
            rtnval=1;
         }
      }
   }
   return rtnval;

}
void lcd_clearMiddle(void)
{  // clears the space between the menu header and the buttons
	lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);
	lcd_Rectangle(1, 41, 320, 204, 1);    // fill left side progress
	lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
}
char * ltrim(char * text)
{
	char i;
   i=0;
   while (text[i]==32) i++;
   return &text[i];
}
void lcd_drawKeyboard()
{
   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
   lcd_Font("24");
	// draw alpha keyboard
	// the button ID for each button is its equivalent ASCII decimal value
	// first row
   lcd_ButtonDef( 49,
		BTN_MOM,
    	BTN_TLXY, 0, 75,
      BTN_SEP, 32, 32,
      BTN_MARGINS, 0, 340-32,
      BTN_TYPE, BUTTON_PRESS,
      BTN_TEXT, "1",
      BTN_TXTOFFSET, 8, 5,
      BTN_BMP, BMP_button_up, BMP_button_dn,
      BTN_END );
   lcd_ButtonDef( 50, BTN_TEXT, "2", BTN_END );
   lcd_ButtonDef( 51, BTN_TEXT, "3", BTN_END );
   lcd_ButtonDef( 52, BTN_TEXT, "4", BTN_END );
   lcd_ButtonDef( 53, BTN_TEXT, "5", BTN_END );
   lcd_ButtonDef( 54, BTN_TEXT, "6", BTN_END );
   lcd_ButtonDef( 55, BTN_TEXT, "7", BTN_END );
   lcd_ButtonDef( 56, BTN_TEXT, "8", BTN_END );
   lcd_ButtonDef( 57, BTN_TEXT, "9", BTN_END );
   lcd_ButtonDef( 48, BTN_TEXT, "0", BTN_END );
// second row
   lcd_ButtonDef( 81, BTN_TEXT, "Q", BTN_END );
   lcd_ButtonDef( 87, BTN_TEXT, "W", BTN_END );
   lcd_ButtonDef( 69, BTN_TEXT, "E", BTN_END );
   lcd_ButtonDef( 82, BTN_TEXT, "R", BTN_END );
   lcd_ButtonDef( 84, BTN_TEXT, "T", BTN_END );
   lcd_ButtonDef( 89, BTN_TEXT, "Y", BTN_END );
   lcd_ButtonDef( 85, BTN_TEXT, "U", BTN_END );
   lcd_ButtonDef( 73, BTN_TEXT, "I", BTN_END );
   lcd_ButtonDef( 79, BTN_TEXT, "O", BTN_END );
   lcd_ButtonDef( 80, BTN_TEXT, "P", BTN_END );
// third row
   lcd_ButtonDef( 65, BTN_TEXT, "A", BTN_END );
   lcd_ButtonDef( 83, BTN_TEXT, "S", BTN_END );
   lcd_ButtonDef( 68, BTN_TEXT, "D", BTN_END );
   lcd_ButtonDef( 70, BTN_TEXT, "F", BTN_END );
   lcd_ButtonDef( 71, BTN_TEXT, "G", BTN_END );
   lcd_ButtonDef( 72, BTN_TEXT, "H", BTN_END );
   lcd_ButtonDef( 74, BTN_TEXT, "J", BTN_END );
   lcd_ButtonDef( 75, BTN_TEXT, "K", BTN_END );
   lcd_ButtonDef( 76, BTN_TEXT, "L", BTN_END );
   lcd_ButtonDef( ':', BTN_TEXT, ":", BTN_END );
// fourth row
   lcd_ButtonDef( 90, BTN_TEXT, "Z", BTN_END );
   lcd_ButtonDef( 88, BTN_TEXT, "X", BTN_END );
   lcd_ButtonDef( 67, BTN_TEXT, "C", BTN_END );
   lcd_ButtonDef( 86, BTN_TEXT, "V", BTN_END );
   lcd_ButtonDef( 66, BTN_TEXT, "B", BTN_END );
   lcd_ButtonDef( 78, BTN_TEXT, "N", BTN_END );
   lcd_ButtonDef( 77, BTN_TEXT, "M", BTN_END );
   lcd_ButtonDef( 46, BTN_TEXT, ".", BTN_END );
   lcd_ButtonDef( 45, BTN_TEXT, "-", BTN_END );
   lcd_Font("16B");
   lcd_ButtonDef(  8, BTN_TEXT, "del", BTN_TXTOFFSET, 6, 10, BTN_END );
   lcd_ButtonDef( 32, BTN_TEXT, "Space", BTN_TLXY, 114, 203,
      BTN_TXTOFFSET, 25, 10,
		BTN_BMP, BMP_92x32_button, BMP_92x32_button_dn, BTN_END );
}
void lcd_showTransSummary()
{
   // uses structure statistics  :  system summary statistics

   char myline[80];     // line to send to the lcd
   char * instr;        // work pointer into myline
   long subtot;         // total of transactions or alarms
   int button;

   button=0;
   while ( (button != BTN_EXIT) && !secTimeout(menu_timeout) )
   {
	   lcd_drawScreen(5, "TRANSACTION SUMMARY");
	   lcd_ButtonDef( BTN_CANCEL,
		      BTN_TXTOFFSET, 9, 9,
	         BTN_TLXY, 5, 205,             // starting x,y for buttons
	         BTN_TEXT, "Reset",
	         BTN_END );

	   lcd_Font("8x12");
	   lcd_DispText(param.station_name[SYSTEM_NAME].name, 10, 50, MODE_NORMAL);
	   lcd_DispText("\n Transactions:", 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Incoming:              %ld", statistics.trans_in);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Outgoing:              %ld", statistics.trans_out);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Total Transactions:    %ld", statistics.trans_in + statistics.trans_out);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   //sprintf(myline, "\n    Grand Total:           %ld", transactionCount());
	   //lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   lcd_DispText("\n Alarms:", 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Incomplete Delivery:   %d", statistics.deliv_alarm);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Diverter Timeout:      %d", statistics.divert_alarm);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   sprintf(myline, "\n  Carrier Lift Timeout:  %d", statistics.cic_lift_alarm);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);
	   subtot=statistics.deliv_alarm+statistics.divert_alarm+statistics.cic_lift_alarm;
	   sprintf(myline, "\n  Total Alarms:          %ld", subtot);
	   lcd_DispText(myline, 0, 0, MODE_NORMAL);

	   // wait for any button
	   menu_timeout = SEC_TIMER + 60;
	   while(((button=lcd_GetTouch(100)) == -1) && !secTimeout(menu_timeout) ) maintenance();
      if (button==BTN_CANCEL)
      {  // Ask: Are You Sure?
      	lcd_Font("16B");
         lcd_BFcolorsB( lcd_LGREY, lcd_LGREY);  // unfill color
         lcd_Rectangle(40, 100, 300, 160, 1);    // fill white
         lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
         lcd_Rectangle(40, 100, 300, 160, 0);    // outline
         lcd_DispText("Press Reset again to confirm\nor Exit to cancel", 60, 115, MODE_TRANS);

	      menu_timeout = SEC_TIMER + 60;
		   while(((button=lcd_GetTouch(100)) == -1) && !secTimeout(menu_timeout) ) maintenance();
         if (button==BTN_CANCEL)
         {  // OK to reset
         	resetStatistics();
         }
         else button=0; // don't really exit, just repaint the screen
      }
   }

}

unsigned long logHead;  // pints to latest entry
unsigned long logTail;  // points to first entry  (if both equal 0 then log is empty)
char logVer;
unsigned long logInfoXaddr;
unsigned long logXaddr;
#define TRANSLOG_SIZE 1000
#define LOG_VERSION   1
void initTransLog(void)
{
	struct trans_log_type trans;
   int status;

	// allocate the xmem
   logInfoXaddr = xalloc(10);
   logXaddr = xalloc(TRANSLOG_SIZE * sizeof(trans));

   // get the header to determine head and tail
   status = xmem2root( &logHead, logInfoXaddr, 4);
   status |= xmem2root( &logTail, logInfoXaddr+4, 4);
   status |= xmem2root( &logVer, logInfoXaddr+8, 1);

   if (status != 0)
   {  // error reading xmem
   	printf("\nError %d initializing transaction log", status);
   }
	// if log version does not match then initialize log
   if (logVer != LOG_VERSION)
   {  // reinit log
   	logTail=0;
      logHead=0;
      logVer = LOG_VERSION;
      root2xmem( logInfoXaddr, &logHead, 4);
      root2xmem( logInfoXaddr+4, &logTail, 4);
      root2xmem( logInfoXaddr+8, &logVer, 1);
      printf("\nTransaction log reset\n");
	}
   // make sure head/tail are plausible
   // either tail=0 and head=0..TRANSLOG_SIZE-1
   // or tail=1..TRANSLOG_SIZE-1 and head=tail-1
   else if ((logTail==0) && (logHead>=0) && (logHead<TRANSLOG_SIZE))
   { // OK
   	printf("\nTrans log contains %ld entries\n", logHead);
   }
   else if ((logTail>0) && (logTail<TRANSLOG_SIZE) && (logTail-logHead==1))
   { // OK
      printf("\nTrans log contains %ld entries\n", TRANSLOG_SIZE);
   }
   else
   { // NOT OK so reinitialize head and tail
   	logTail=0;
      logHead=0;
      root2xmem( logInfoXaddr, &logHead, 4);
      root2xmem( logInfoXaddr+4, &logTail, 4);
      printf("\nTrans log initialized\n");
   }
}
//#define RS232_MONITOR_F
void downloadTransLog()
{  // open com port and transmit the log
	char buf[120];
   char crlf[3];
   long entry;
   char j;
   struct trans_log_type log;
   struct tm time;
   unsigned long startTime;

   crlf[0]=13;
   crlf[1]=10;
   crlf[2]=0;

   // give some status
 	lcd_drawScreen(3, "DOWNLOAD LOG");
   lcd_Font("24");
   lcd_DispText("In progress ...", 80, 80, MODE_NORMAL); // show the default name

   // open com port
   serFdatabits(PARAM_8BIT);
   serFparity(PARAM_NOPARITY);
   serFopen(19200);

   // write header
   mktm(&time, SEC_TIMER);
   sprintf(buf,"Transaction Log Dump at %02d/%02d/%02d %02d:%02d:%02d%s",
      		time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec, crlf);
   serFputs(buf);
   sprintf(buf, "Date,Time,Source,Destination,Duration,Status,Flags%s", crlf);
   serFputs(buf);

	for (entry=0; entry<sizeOfTransLog(); entry++)
   {
   	// get entry
		if (getTransaction((int)entry, &log) == 0)
      {  mktm(&time, log.start_tm);
      	if (log.status <= LAST_TRANS_EVENT)
         {
	         // format entry
	         sprintf(buf, "%02d/%02d/%02d,%02d:%02d:%02d,%s,%s,%d,%d,%d%s",
	            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
	            log.source_sta < SYSTEM_NAME ? param.station_name[log.source_sta].name : "??",
	            log.dest_sta < SYSTEM_NAME ? param.station_name[log.dest_sta].name : "??",
	            (int)(log.end_tm - log.start_tm),
	            (int)log.status, (int)log.flags, crlf );
         } else if (log.status == ESTS_DOOROPEN)
         {  // This is a door open event
         	sprintf(buf, "%02d/%02d/%02d,%02d:%02d:%02d,%s,,%d,%d,%d%s",
            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
            "DOOR OPEN IN TRANS",
            (int)(log.end_tm - log.start_tm),
            (int) log.status, (int) log.flags, crlf );
         } else if (log.status == ESTS_MANPURGE)
         {  // This is a manual purge event
         	sprintf(buf, "%02d/%02d/%02d,%02d:%02d:%02d,%s,,%d,%d,%d%s",
            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
            "MANUAL PURGE",
            (int)(log.end_tm - log.start_tm),
            (int) log.status, (int) log.flags, crlf );
         } else if (log.status == ESTS_AUTOPURGE)
         {  // This is an automatic purge event
         	sprintf(buf, "%02d/%02d/%02d,%02d:%02d:%02d,%s,,%d,%d,%d%s",
            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
            "AUTOMATIC PURGE",
            (int)(log.end_tm - log.start_tm),
            (int) log.status, (int) log.flags, crlf );
         }

         // make sure there is space in the buffer
			startTime = MS_TIMER;
         while ((serFwrFree() < FOUTBUFSIZE) && ((MS_TIMER-startTime) < 500)) maintenance();

	      // write to com port
		   serFputs(buf);
         maintenance();
      }
   }
	startTime = MS_TIMER;
   // wait for buffer to empty
   while ((serFwrUsed() != 0) && ((MS_TIMER-startTime) < 1000)) maintenance();

   // close com port
   msDelay(20); // wait till last character is sent
	serFclose();
}
void addTransaction(struct trans_log_type trans)
{
	long memOffset;
   memOffset = logHead * sizeof(trans);
   root2xmem( logXaddr+memOffset, &trans, sizeof(trans));
	logHead++; // increment logHead
   if (logHead==TRANSLOG_SIZE) logHead=0;  // check for wraparound
   if (logHead==logTail)							// check for full log
   {  logTail++;									// bump the tail
	   if (logTail==TRANSLOG_SIZE) logTail=0;	// check for wraparound
   }
   // save head/tail back to xmem
   root2xmem( logInfoXaddr, &logHead, 4);
   root2xmem( logInfoXaddr+4, &logTail, 4);
//printf("\nAdded transaction at %ld with status %d and flags %d\n", SEC_TIMER, (int)trans.status, (int)trans.flags);
}
long sizeOfTransLog(void)
{  // how many entries in the log
   if ((logTail==0) && (logHead>=0) && (logHead<TRANSLOG_SIZE))
   { // OK
   	return logHead;
   }
   else if ((logTail>0) && (logTail<TRANSLOG_SIZE) && (logTail-logHead==1))
   { // OK
      return TRANSLOG_SIZE;
   }
}
int getTransaction(int entry, struct trans_log_type *trans)
{  // returns the n'th entry in the trans log
   // entry can be 0 .. sizeOfLog-1
   // return value = 0 if success or 1 if entry non-existant
   long memOffset;
   if (entry >= sizeOfTransLog()) return 1;
   memOffset = ((logTail+entry) % TRANSLOG_SIZE) * sizeof(*trans);
   xmem2root( trans, logXaddr+memOffset, sizeof(*trans));
   return 0;
}
#define TRANS_PER_PAGE 10
void lcd_showTransactions(void)
{  // shows the transaction log on the screen
   int page;
   int lastPage;
   int button;
   int transPerPage;

   lcd_drawScreen(8, "TRANSACTION LOG");		// redraw main screen

   // count how many pages we can show
   page=0;
   lastPage = (int)sizeOfTransLog() / TRANS_PER_PAGE;
	lcd_showTransPage(page, lastPage);

	button=0;
   while ((button != BTN_CANCEL) && !secTimeout(menu_timeout))
   {  maintenance();
   	button = lcd_GetTouch(100);
      if (button != -1)
      {  // valid button pressed
         menu_timeout = SEC_TIMER + 60;
         switch( button )
         {
         case BTN_PREV:
         	if (page > 0) page--;
            lcd_showTransPage(page, lastPage);
         	break;
         case BTN_NEXT:
            if (page < lastPage) page++;
            lcd_showTransPage(page, lastPage);
         	break;
         }
      }
   }
}

void lcd_showTransPage(int page, int lastPage)
{	// page 0 shows the last transaction
	int x;
	int y, dy;
   long entry;
   char j;
   char buf[80];
   struct trans_log_type trans;
   struct tm time;

   //strcpy(buf, "mm/dd/yy hh:mm:ss sourcesta.. -> destinsta.. sss sec");
   entry = sizeOfTransLog() -1 - page * TRANS_PER_PAGE;
   j=0;
   y=44; dy=14; x=5;
   lcd_Font("6x9");
   // print header
   sprintf(buf, "DATE     TIME     FROM          TO          Sec StFl");
   lcd_DispText(buf, x, y, MODE_NORMAL);
   y+=dy;

   while ( (j < TRANS_PER_PAGE) && (entry >= 0) ) //< sizeOfTransLog()))
   {
		if (getTransaction((int)entry, &trans) == 0)
      {  mktm(&time, trans.start_tm);
      	lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
      	if (trans.status <= LAST_TRANS_EVENT)
         {  // This is a transaction
	         sprintf(buf, "%02d/%02d/%02d %02d:%02d:%02d %-11s-> %-11s %3d %2x%2x",
	            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
	            trans.source_sta < SYSTEM_NAME ? param.station_name[trans.source_sta].name : "??",
	            trans.dest_sta < SYSTEM_NAME ? param.station_name[trans.dest_sta].name : "??",
	            (int)(trans.end_tm - trans.start_tm),
	            (int) trans.status, (int) trans.flags );
            if (trans.status != 0)  			 lcd_BFcolorsB( lcd_RED, lcd_WHITE);  // alarm trans colors
	         else if (trans.flags & FLAG_STAT) lcd_BFcolorsD( 0xAA0, 0xFFF); //lcd_BFcolorsB( lcd_YELLOW, lcd_WHITE);  // stat trans colors
            else if (trans.flags & (FLAG_CRETURN || FLAG_ARETURN)) lcd_BFcolorsB( lcd_GREEN, lcd_WHITE);  // c.return trans colors
	         //else     lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
         } else if (trans.status == ESTS_DOOROPEN)
         {  // This is a door open event
         	sprintf(buf, "         %02d:%02d:%02d %-25s %3d %2x%2x",
            time.tm_hour, time.tm_min, time.tm_sec,
            "DOOR OPEN IN TRANS",
            (int)(trans.end_tm - trans.start_tm),
            (int) trans.status, (int) trans.flags );
            lcd_BFcolorsB( lcd_MAGENTA, lcd_WHITE);
         } else if (trans.status == ESTS_MANPURGE)
         {  // This is a manual purge event
         	sprintf(buf, "%02d/%02d/%02d %02d:%02d:%02d %-25s %3d %2x%2x",
            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
            "MANUAL PURGE",
            (int)(trans.end_tm - trans.start_tm),
            (int) trans.status, (int) trans.flags );
	      	lcd_BFcolorsB( lcd_BLUE, lcd_WHITE);
         } else if (trans.status == ESTS_AUTOPURGE)
         {  // This is an automatic purge event
         	sprintf(buf, "%02d/%02d/%02d %02d:%02d:%02d %-25s %3d %2x%2x",
            time.tm_mon, time.tm_mday, time.tm_year%100, time.tm_hour, time.tm_min, time.tm_sec,
            "AUTOMATIC PURGE",
            (int)(trans.end_tm - trans.start_tm),
            (int) trans.status, (int) trans.flags );
	      	lcd_BFcolorsB( lcd_BLUE, lcd_WHITE);
         }
		   lcd_DispText(buf, x, y, MODE_NORMAL);
         y+=dy;
      }
      j++;
      entry--;
   }
   if (j < TRANS_PER_PAGE)
   {  // clear the rest of the work area
	   lcd_BFcolorsB( lcd_WHITE, lcd_WHITE);
	   lcd_Rectangle(1, y, 320, 204, 1);    // fill left side progress
	   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	}
   lcd_showPage(page+1, lastPage+1);
}
void lcd_showPage(int thisPage, int lastPage)
{  // show page x of y
   char buf[25];
   sprintf(buf, "Page %d of %d  ", thisPage, lastPage);
   lcd_Font("8x12");
   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
   lcd_DispText(buf, 150, 218, MODE_NORMAL);
}
void lcd_screenSaver(char brightness)
{  // lower brightness after 60 seconds of dim command
   // works like a 2-state watchdog.  if brightness is not LCD_BRIGHT after 60 sec then make dim
	static char lastBright;
   static unsigned long dimTimer;
   #GLOBAL_INIT
   { lastBright==LCD_BRIGHT;
     dimTimer=MS_TIMER;
   }

   if ((brightness==LCD_BRIGHT) && (lastBright==LCD_DIM))
   {  lcd_Backlight(LCD_DIM); //brightness);
   	dimTimer=MS_TIMER;
   }
   else if (brightness == LCD_DIM)
   {  if (MS_TIMER - dimTimer > 60000)
   	{  lcd_Backlight(LCD_DIM); //brightness);
	   	dimTimer=MS_TIMER;  // retrys again in 60 sec
      }
   }
}

void lcd_smartPrompt(char promptNum)
{  // prints a smartPrompt at the bottom of the screen
	char msg[30];
   switch (promptNum)
   {
   case 0: strcpy(msg, "                        "); break;
   case 1: strcpy(msg, "Insert Carrier to Begin"); break;
   case 2: strcpy(msg, "Press Directory to Send"); break;
   case 3: strcpy(msg, "Remove Arrived Carrier"); break;
   case 4: strcpy(msg, "Close Door to Continue"); break;
   default: msg[0]=0; break;
   }
   if (msg[0]!=0)
   {  // show the message
      lcd_Font("18BC");
	   lcd_BFcolorsB( lcd_BLACK, lcd_WHITE);
	   lcd_DispText(msg, 100, 180, MODE_NORMAL);
   }
}